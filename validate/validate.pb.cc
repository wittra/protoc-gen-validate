// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: validate/validate.proto

#include "validate/validate.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace validate {
PROTOBUF_CONSTEXPR FieldRules::FieldRules(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.message_)*/nullptr
  , /*decltype(_impl_.type_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct FieldRulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FieldRulesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FieldRulesDefaultTypeInternal() {}
  union {
    FieldRules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FieldRulesDefaultTypeInternal _FieldRules_default_instance_;
PROTOBUF_CONSTEXPR FloatRules::FloatRules(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.in_)*/{}
  , /*decltype(_impl_.not_in_)*/{}
  , /*decltype(_impl_.const__)*/0
  , /*decltype(_impl_.lt_)*/0
  , /*decltype(_impl_.lte_)*/0
  , /*decltype(_impl_.gt_)*/0
  , /*decltype(_impl_.gte_)*/0
  , /*decltype(_impl_.ignore_empty_)*/false} {}
struct FloatRulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FloatRulesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FloatRulesDefaultTypeInternal() {}
  union {
    FloatRules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FloatRulesDefaultTypeInternal _FloatRules_default_instance_;
PROTOBUF_CONSTEXPR DoubleRules::DoubleRules(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.in_)*/{}
  , /*decltype(_impl_.not_in_)*/{}
  , /*decltype(_impl_.const__)*/0
  , /*decltype(_impl_.lt_)*/0
  , /*decltype(_impl_.lte_)*/0
  , /*decltype(_impl_.gt_)*/0
  , /*decltype(_impl_.gte_)*/0
  , /*decltype(_impl_.ignore_empty_)*/false} {}
struct DoubleRulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DoubleRulesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DoubleRulesDefaultTypeInternal() {}
  union {
    DoubleRules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DoubleRulesDefaultTypeInternal _DoubleRules_default_instance_;
PROTOBUF_CONSTEXPR Int32Rules::Int32Rules(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.in_)*/{}
  , /*decltype(_impl_.not_in_)*/{}
  , /*decltype(_impl_.const__)*/0
  , /*decltype(_impl_.lt_)*/0
  , /*decltype(_impl_.lte_)*/0
  , /*decltype(_impl_.gt_)*/0
  , /*decltype(_impl_.gte_)*/0
  , /*decltype(_impl_.ignore_empty_)*/false} {}
struct Int32RulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Int32RulesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Int32RulesDefaultTypeInternal() {}
  union {
    Int32Rules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Int32RulesDefaultTypeInternal _Int32Rules_default_instance_;
PROTOBUF_CONSTEXPR Int64Rules::Int64Rules(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.in_)*/{}
  , /*decltype(_impl_.not_in_)*/{}
  , /*decltype(_impl_.const__)*/int64_t{0}
  , /*decltype(_impl_.lt_)*/int64_t{0}
  , /*decltype(_impl_.lte_)*/int64_t{0}
  , /*decltype(_impl_.gt_)*/int64_t{0}
  , /*decltype(_impl_.gte_)*/int64_t{0}
  , /*decltype(_impl_.ignore_empty_)*/false} {}
struct Int64RulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Int64RulesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Int64RulesDefaultTypeInternal() {}
  union {
    Int64Rules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Int64RulesDefaultTypeInternal _Int64Rules_default_instance_;
PROTOBUF_CONSTEXPR UInt32Rules::UInt32Rules(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.in_)*/{}
  , /*decltype(_impl_.not_in_)*/{}
  , /*decltype(_impl_.const__)*/0u
  , /*decltype(_impl_.lt_)*/0u
  , /*decltype(_impl_.lte_)*/0u
  , /*decltype(_impl_.gt_)*/0u
  , /*decltype(_impl_.gte_)*/0u
  , /*decltype(_impl_.ignore_empty_)*/false} {}
struct UInt32RulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UInt32RulesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UInt32RulesDefaultTypeInternal() {}
  union {
    UInt32Rules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UInt32RulesDefaultTypeInternal _UInt32Rules_default_instance_;
PROTOBUF_CONSTEXPR UInt64Rules::UInt64Rules(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.in_)*/{}
  , /*decltype(_impl_.not_in_)*/{}
  , /*decltype(_impl_.const__)*/uint64_t{0u}
  , /*decltype(_impl_.lt_)*/uint64_t{0u}
  , /*decltype(_impl_.lte_)*/uint64_t{0u}
  , /*decltype(_impl_.gt_)*/uint64_t{0u}
  , /*decltype(_impl_.gte_)*/uint64_t{0u}
  , /*decltype(_impl_.ignore_empty_)*/false} {}
struct UInt64RulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UInt64RulesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UInt64RulesDefaultTypeInternal() {}
  union {
    UInt64Rules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UInt64RulesDefaultTypeInternal _UInt64Rules_default_instance_;
PROTOBUF_CONSTEXPR SInt32Rules::SInt32Rules(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.in_)*/{}
  , /*decltype(_impl_.not_in_)*/{}
  , /*decltype(_impl_.const__)*/0
  , /*decltype(_impl_.lt_)*/0
  , /*decltype(_impl_.lte_)*/0
  , /*decltype(_impl_.gt_)*/0
  , /*decltype(_impl_.gte_)*/0
  , /*decltype(_impl_.ignore_empty_)*/false} {}
struct SInt32RulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SInt32RulesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SInt32RulesDefaultTypeInternal() {}
  union {
    SInt32Rules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SInt32RulesDefaultTypeInternal _SInt32Rules_default_instance_;
PROTOBUF_CONSTEXPR SInt64Rules::SInt64Rules(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.in_)*/{}
  , /*decltype(_impl_.not_in_)*/{}
  , /*decltype(_impl_.const__)*/int64_t{0}
  , /*decltype(_impl_.lt_)*/int64_t{0}
  , /*decltype(_impl_.lte_)*/int64_t{0}
  , /*decltype(_impl_.gt_)*/int64_t{0}
  , /*decltype(_impl_.gte_)*/int64_t{0}
  , /*decltype(_impl_.ignore_empty_)*/false} {}
struct SInt64RulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SInt64RulesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SInt64RulesDefaultTypeInternal() {}
  union {
    SInt64Rules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SInt64RulesDefaultTypeInternal _SInt64Rules_default_instance_;
PROTOBUF_CONSTEXPR Fixed32Rules::Fixed32Rules(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.in_)*/{}
  , /*decltype(_impl_.not_in_)*/{}
  , /*decltype(_impl_.const__)*/0u
  , /*decltype(_impl_.lt_)*/0u
  , /*decltype(_impl_.lte_)*/0u
  , /*decltype(_impl_.gt_)*/0u
  , /*decltype(_impl_.gte_)*/0u
  , /*decltype(_impl_.ignore_empty_)*/false} {}
struct Fixed32RulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Fixed32RulesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Fixed32RulesDefaultTypeInternal() {}
  union {
    Fixed32Rules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Fixed32RulesDefaultTypeInternal _Fixed32Rules_default_instance_;
PROTOBUF_CONSTEXPR Fixed64Rules::Fixed64Rules(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.in_)*/{}
  , /*decltype(_impl_.not_in_)*/{}
  , /*decltype(_impl_.const__)*/uint64_t{0u}
  , /*decltype(_impl_.lt_)*/uint64_t{0u}
  , /*decltype(_impl_.lte_)*/uint64_t{0u}
  , /*decltype(_impl_.gt_)*/uint64_t{0u}
  , /*decltype(_impl_.gte_)*/uint64_t{0u}
  , /*decltype(_impl_.ignore_empty_)*/false} {}
struct Fixed64RulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Fixed64RulesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Fixed64RulesDefaultTypeInternal() {}
  union {
    Fixed64Rules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Fixed64RulesDefaultTypeInternal _Fixed64Rules_default_instance_;
PROTOBUF_CONSTEXPR SFixed32Rules::SFixed32Rules(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.in_)*/{}
  , /*decltype(_impl_.not_in_)*/{}
  , /*decltype(_impl_.const__)*/0
  , /*decltype(_impl_.lt_)*/0
  , /*decltype(_impl_.lte_)*/0
  , /*decltype(_impl_.gt_)*/0
  , /*decltype(_impl_.gte_)*/0
  , /*decltype(_impl_.ignore_empty_)*/false} {}
struct SFixed32RulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SFixed32RulesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SFixed32RulesDefaultTypeInternal() {}
  union {
    SFixed32Rules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SFixed32RulesDefaultTypeInternal _SFixed32Rules_default_instance_;
PROTOBUF_CONSTEXPR SFixed64Rules::SFixed64Rules(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.in_)*/{}
  , /*decltype(_impl_.not_in_)*/{}
  , /*decltype(_impl_.const__)*/int64_t{0}
  , /*decltype(_impl_.lt_)*/int64_t{0}
  , /*decltype(_impl_.lte_)*/int64_t{0}
  , /*decltype(_impl_.gt_)*/int64_t{0}
  , /*decltype(_impl_.gte_)*/int64_t{0}
  , /*decltype(_impl_.ignore_empty_)*/false} {}
struct SFixed64RulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SFixed64RulesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SFixed64RulesDefaultTypeInternal() {}
  union {
    SFixed64Rules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SFixed64RulesDefaultTypeInternal _SFixed64Rules_default_instance_;
PROTOBUF_CONSTEXPR BoolRules::BoolRules(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.const__)*/false} {}
struct BoolRulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BoolRulesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BoolRulesDefaultTypeInternal() {}
  union {
    BoolRules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BoolRulesDefaultTypeInternal _BoolRules_default_instance_;
PROTOBUF_CONSTEXPR StringRules::StringRules(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.in_)*/{}
  , /*decltype(_impl_.not_in_)*/{}
  , /*decltype(_impl_.const__)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.pattern_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.prefix_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.suffix_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.contains_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.not_contains_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.min_len_)*/uint64_t{0u}
  , /*decltype(_impl_.max_len_)*/uint64_t{0u}
  , /*decltype(_impl_.min_bytes_)*/uint64_t{0u}
  , /*decltype(_impl_.max_bytes_)*/uint64_t{0u}
  , /*decltype(_impl_.len_)*/uint64_t{0u}
  , /*decltype(_impl_.len_bytes_)*/uint64_t{0u}
  , /*decltype(_impl_.ignore_empty_)*/false
  , /*decltype(_impl_.strict_)*/true
  , /*decltype(_impl_.well_known_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct StringRulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StringRulesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StringRulesDefaultTypeInternal() {}
  union {
    StringRules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StringRulesDefaultTypeInternal _StringRules_default_instance_;
PROTOBUF_CONSTEXPR BytesRules::BytesRules(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.in_)*/{}
  , /*decltype(_impl_.not_in_)*/{}
  , /*decltype(_impl_.const__)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.pattern_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.prefix_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.suffix_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.contains_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.min_len_)*/uint64_t{0u}
  , /*decltype(_impl_.max_len_)*/uint64_t{0u}
  , /*decltype(_impl_.len_)*/uint64_t{0u}
  , /*decltype(_impl_.ignore_empty_)*/false
  , /*decltype(_impl_.well_known_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct BytesRulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BytesRulesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BytesRulesDefaultTypeInternal() {}
  union {
    BytesRules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BytesRulesDefaultTypeInternal _BytesRules_default_instance_;
PROTOBUF_CONSTEXPR EnumRules::EnumRules(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.in_)*/{}
  , /*decltype(_impl_.not_in_)*/{}
  , /*decltype(_impl_.const__)*/0
  , /*decltype(_impl_.defined_only_)*/false} {}
struct EnumRulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EnumRulesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EnumRulesDefaultTypeInternal() {}
  union {
    EnumRules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EnumRulesDefaultTypeInternal _EnumRules_default_instance_;
PROTOBUF_CONSTEXPR MessageRules::MessageRules(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.skip_)*/false
  , /*decltype(_impl_.required_)*/false} {}
struct MessageRulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MessageRulesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MessageRulesDefaultTypeInternal() {}
  union {
    MessageRules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MessageRulesDefaultTypeInternal _MessageRules_default_instance_;
PROTOBUF_CONSTEXPR RepeatedRules::RepeatedRules(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.items_)*/nullptr
  , /*decltype(_impl_.min_items_)*/uint64_t{0u}
  , /*decltype(_impl_.max_items_)*/uint64_t{0u}
  , /*decltype(_impl_.unique_)*/false
  , /*decltype(_impl_.ignore_empty_)*/false} {}
struct RepeatedRulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RepeatedRulesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RepeatedRulesDefaultTypeInternal() {}
  union {
    RepeatedRules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RepeatedRulesDefaultTypeInternal _RepeatedRules_default_instance_;
PROTOBUF_CONSTEXPR MapRules::MapRules(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.keys_)*/nullptr
  , /*decltype(_impl_.values_)*/nullptr
  , /*decltype(_impl_.min_pairs_)*/uint64_t{0u}
  , /*decltype(_impl_.max_pairs_)*/uint64_t{0u}
  , /*decltype(_impl_.no_sparse_)*/false
  , /*decltype(_impl_.ignore_empty_)*/false} {}
struct MapRulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MapRulesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MapRulesDefaultTypeInternal() {}
  union {
    MapRules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MapRulesDefaultTypeInternal _MapRules_default_instance_;
PROTOBUF_CONSTEXPR AnyRules::AnyRules(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.in_)*/{}
  , /*decltype(_impl_.not_in_)*/{}
  , /*decltype(_impl_.required_)*/false} {}
struct AnyRulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AnyRulesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AnyRulesDefaultTypeInternal() {}
  union {
    AnyRules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AnyRulesDefaultTypeInternal _AnyRules_default_instance_;
PROTOBUF_CONSTEXPR DurationRules::DurationRules(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.in_)*/{}
  , /*decltype(_impl_.not_in_)*/{}
  , /*decltype(_impl_.const__)*/nullptr
  , /*decltype(_impl_.lt_)*/nullptr
  , /*decltype(_impl_.lte_)*/nullptr
  , /*decltype(_impl_.gt_)*/nullptr
  , /*decltype(_impl_.gte_)*/nullptr
  , /*decltype(_impl_.required_)*/false} {}
struct DurationRulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DurationRulesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DurationRulesDefaultTypeInternal() {}
  union {
    DurationRules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DurationRulesDefaultTypeInternal _DurationRules_default_instance_;
PROTOBUF_CONSTEXPR TimestampRules::TimestampRules(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.const__)*/nullptr
  , /*decltype(_impl_.lt_)*/nullptr
  , /*decltype(_impl_.lte_)*/nullptr
  , /*decltype(_impl_.gt_)*/nullptr
  , /*decltype(_impl_.gte_)*/nullptr
  , /*decltype(_impl_.within_)*/nullptr
  , /*decltype(_impl_.required_)*/false
  , /*decltype(_impl_.lt_now_)*/false
  , /*decltype(_impl_.gt_now_)*/false} {}
struct TimestampRulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TimestampRulesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TimestampRulesDefaultTypeInternal() {}
  union {
    TimestampRules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TimestampRulesDefaultTypeInternal _TimestampRules_default_instance_;
}  // namespace validate
static ::_pb::Metadata file_level_metadata_validate_2fvalidate_2eproto[23];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_validate_2fvalidate_2eproto[1];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_validate_2fvalidate_2eproto = nullptr;

const uint32_t TableStruct_validate_2fvalidate_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::validate::FieldRules, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::FieldRules, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::validate::FieldRules, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::validate::FieldRules, _impl_.message_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::validate::FieldRules, _impl_.type_),
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::validate::FloatRules, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::FloatRules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::validate::FloatRules, _impl_.const__),
  PROTOBUF_FIELD_OFFSET(::validate::FloatRules, _impl_.lt_),
  PROTOBUF_FIELD_OFFSET(::validate::FloatRules, _impl_.lte_),
  PROTOBUF_FIELD_OFFSET(::validate::FloatRules, _impl_.gt_),
  PROTOBUF_FIELD_OFFSET(::validate::FloatRules, _impl_.gte_),
  PROTOBUF_FIELD_OFFSET(::validate::FloatRules, _impl_.in_),
  PROTOBUF_FIELD_OFFSET(::validate::FloatRules, _impl_.not_in_),
  PROTOBUF_FIELD_OFFSET(::validate::FloatRules, _impl_.ignore_empty_),
  0,
  1,
  2,
  3,
  4,
  ~0u,
  ~0u,
  5,
  PROTOBUF_FIELD_OFFSET(::validate::DoubleRules, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::DoubleRules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::validate::DoubleRules, _impl_.const__),
  PROTOBUF_FIELD_OFFSET(::validate::DoubleRules, _impl_.lt_),
  PROTOBUF_FIELD_OFFSET(::validate::DoubleRules, _impl_.lte_),
  PROTOBUF_FIELD_OFFSET(::validate::DoubleRules, _impl_.gt_),
  PROTOBUF_FIELD_OFFSET(::validate::DoubleRules, _impl_.gte_),
  PROTOBUF_FIELD_OFFSET(::validate::DoubleRules, _impl_.in_),
  PROTOBUF_FIELD_OFFSET(::validate::DoubleRules, _impl_.not_in_),
  PROTOBUF_FIELD_OFFSET(::validate::DoubleRules, _impl_.ignore_empty_),
  0,
  1,
  2,
  3,
  4,
  ~0u,
  ~0u,
  5,
  PROTOBUF_FIELD_OFFSET(::validate::Int32Rules, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::Int32Rules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::validate::Int32Rules, _impl_.const__),
  PROTOBUF_FIELD_OFFSET(::validate::Int32Rules, _impl_.lt_),
  PROTOBUF_FIELD_OFFSET(::validate::Int32Rules, _impl_.lte_),
  PROTOBUF_FIELD_OFFSET(::validate::Int32Rules, _impl_.gt_),
  PROTOBUF_FIELD_OFFSET(::validate::Int32Rules, _impl_.gte_),
  PROTOBUF_FIELD_OFFSET(::validate::Int32Rules, _impl_.in_),
  PROTOBUF_FIELD_OFFSET(::validate::Int32Rules, _impl_.not_in_),
  PROTOBUF_FIELD_OFFSET(::validate::Int32Rules, _impl_.ignore_empty_),
  0,
  1,
  2,
  3,
  4,
  ~0u,
  ~0u,
  5,
  PROTOBUF_FIELD_OFFSET(::validate::Int64Rules, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::Int64Rules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::validate::Int64Rules, _impl_.const__),
  PROTOBUF_FIELD_OFFSET(::validate::Int64Rules, _impl_.lt_),
  PROTOBUF_FIELD_OFFSET(::validate::Int64Rules, _impl_.lte_),
  PROTOBUF_FIELD_OFFSET(::validate::Int64Rules, _impl_.gt_),
  PROTOBUF_FIELD_OFFSET(::validate::Int64Rules, _impl_.gte_),
  PROTOBUF_FIELD_OFFSET(::validate::Int64Rules, _impl_.in_),
  PROTOBUF_FIELD_OFFSET(::validate::Int64Rules, _impl_.not_in_),
  PROTOBUF_FIELD_OFFSET(::validate::Int64Rules, _impl_.ignore_empty_),
  0,
  1,
  2,
  3,
  4,
  ~0u,
  ~0u,
  5,
  PROTOBUF_FIELD_OFFSET(::validate::UInt32Rules, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::UInt32Rules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::validate::UInt32Rules, _impl_.const__),
  PROTOBUF_FIELD_OFFSET(::validate::UInt32Rules, _impl_.lt_),
  PROTOBUF_FIELD_OFFSET(::validate::UInt32Rules, _impl_.lte_),
  PROTOBUF_FIELD_OFFSET(::validate::UInt32Rules, _impl_.gt_),
  PROTOBUF_FIELD_OFFSET(::validate::UInt32Rules, _impl_.gte_),
  PROTOBUF_FIELD_OFFSET(::validate::UInt32Rules, _impl_.in_),
  PROTOBUF_FIELD_OFFSET(::validate::UInt32Rules, _impl_.not_in_),
  PROTOBUF_FIELD_OFFSET(::validate::UInt32Rules, _impl_.ignore_empty_),
  0,
  1,
  2,
  3,
  4,
  ~0u,
  ~0u,
  5,
  PROTOBUF_FIELD_OFFSET(::validate::UInt64Rules, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::UInt64Rules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::validate::UInt64Rules, _impl_.const__),
  PROTOBUF_FIELD_OFFSET(::validate::UInt64Rules, _impl_.lt_),
  PROTOBUF_FIELD_OFFSET(::validate::UInt64Rules, _impl_.lte_),
  PROTOBUF_FIELD_OFFSET(::validate::UInt64Rules, _impl_.gt_),
  PROTOBUF_FIELD_OFFSET(::validate::UInt64Rules, _impl_.gte_),
  PROTOBUF_FIELD_OFFSET(::validate::UInt64Rules, _impl_.in_),
  PROTOBUF_FIELD_OFFSET(::validate::UInt64Rules, _impl_.not_in_),
  PROTOBUF_FIELD_OFFSET(::validate::UInt64Rules, _impl_.ignore_empty_),
  0,
  1,
  2,
  3,
  4,
  ~0u,
  ~0u,
  5,
  PROTOBUF_FIELD_OFFSET(::validate::SInt32Rules, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::SInt32Rules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::validate::SInt32Rules, _impl_.const__),
  PROTOBUF_FIELD_OFFSET(::validate::SInt32Rules, _impl_.lt_),
  PROTOBUF_FIELD_OFFSET(::validate::SInt32Rules, _impl_.lte_),
  PROTOBUF_FIELD_OFFSET(::validate::SInt32Rules, _impl_.gt_),
  PROTOBUF_FIELD_OFFSET(::validate::SInt32Rules, _impl_.gte_),
  PROTOBUF_FIELD_OFFSET(::validate::SInt32Rules, _impl_.in_),
  PROTOBUF_FIELD_OFFSET(::validate::SInt32Rules, _impl_.not_in_),
  PROTOBUF_FIELD_OFFSET(::validate::SInt32Rules, _impl_.ignore_empty_),
  0,
  1,
  2,
  3,
  4,
  ~0u,
  ~0u,
  5,
  PROTOBUF_FIELD_OFFSET(::validate::SInt64Rules, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::SInt64Rules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::validate::SInt64Rules, _impl_.const__),
  PROTOBUF_FIELD_OFFSET(::validate::SInt64Rules, _impl_.lt_),
  PROTOBUF_FIELD_OFFSET(::validate::SInt64Rules, _impl_.lte_),
  PROTOBUF_FIELD_OFFSET(::validate::SInt64Rules, _impl_.gt_),
  PROTOBUF_FIELD_OFFSET(::validate::SInt64Rules, _impl_.gte_),
  PROTOBUF_FIELD_OFFSET(::validate::SInt64Rules, _impl_.in_),
  PROTOBUF_FIELD_OFFSET(::validate::SInt64Rules, _impl_.not_in_),
  PROTOBUF_FIELD_OFFSET(::validate::SInt64Rules, _impl_.ignore_empty_),
  0,
  1,
  2,
  3,
  4,
  ~0u,
  ~0u,
  5,
  PROTOBUF_FIELD_OFFSET(::validate::Fixed32Rules, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::Fixed32Rules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::validate::Fixed32Rules, _impl_.const__),
  PROTOBUF_FIELD_OFFSET(::validate::Fixed32Rules, _impl_.lt_),
  PROTOBUF_FIELD_OFFSET(::validate::Fixed32Rules, _impl_.lte_),
  PROTOBUF_FIELD_OFFSET(::validate::Fixed32Rules, _impl_.gt_),
  PROTOBUF_FIELD_OFFSET(::validate::Fixed32Rules, _impl_.gte_),
  PROTOBUF_FIELD_OFFSET(::validate::Fixed32Rules, _impl_.in_),
  PROTOBUF_FIELD_OFFSET(::validate::Fixed32Rules, _impl_.not_in_),
  PROTOBUF_FIELD_OFFSET(::validate::Fixed32Rules, _impl_.ignore_empty_),
  0,
  1,
  2,
  3,
  4,
  ~0u,
  ~0u,
  5,
  PROTOBUF_FIELD_OFFSET(::validate::Fixed64Rules, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::Fixed64Rules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::validate::Fixed64Rules, _impl_.const__),
  PROTOBUF_FIELD_OFFSET(::validate::Fixed64Rules, _impl_.lt_),
  PROTOBUF_FIELD_OFFSET(::validate::Fixed64Rules, _impl_.lte_),
  PROTOBUF_FIELD_OFFSET(::validate::Fixed64Rules, _impl_.gt_),
  PROTOBUF_FIELD_OFFSET(::validate::Fixed64Rules, _impl_.gte_),
  PROTOBUF_FIELD_OFFSET(::validate::Fixed64Rules, _impl_.in_),
  PROTOBUF_FIELD_OFFSET(::validate::Fixed64Rules, _impl_.not_in_),
  PROTOBUF_FIELD_OFFSET(::validate::Fixed64Rules, _impl_.ignore_empty_),
  0,
  1,
  2,
  3,
  4,
  ~0u,
  ~0u,
  5,
  PROTOBUF_FIELD_OFFSET(::validate::SFixed32Rules, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::SFixed32Rules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::validate::SFixed32Rules, _impl_.const__),
  PROTOBUF_FIELD_OFFSET(::validate::SFixed32Rules, _impl_.lt_),
  PROTOBUF_FIELD_OFFSET(::validate::SFixed32Rules, _impl_.lte_),
  PROTOBUF_FIELD_OFFSET(::validate::SFixed32Rules, _impl_.gt_),
  PROTOBUF_FIELD_OFFSET(::validate::SFixed32Rules, _impl_.gte_),
  PROTOBUF_FIELD_OFFSET(::validate::SFixed32Rules, _impl_.in_),
  PROTOBUF_FIELD_OFFSET(::validate::SFixed32Rules, _impl_.not_in_),
  PROTOBUF_FIELD_OFFSET(::validate::SFixed32Rules, _impl_.ignore_empty_),
  0,
  1,
  2,
  3,
  4,
  ~0u,
  ~0u,
  5,
  PROTOBUF_FIELD_OFFSET(::validate::SFixed64Rules, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::SFixed64Rules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::validate::SFixed64Rules, _impl_.const__),
  PROTOBUF_FIELD_OFFSET(::validate::SFixed64Rules, _impl_.lt_),
  PROTOBUF_FIELD_OFFSET(::validate::SFixed64Rules, _impl_.lte_),
  PROTOBUF_FIELD_OFFSET(::validate::SFixed64Rules, _impl_.gt_),
  PROTOBUF_FIELD_OFFSET(::validate::SFixed64Rules, _impl_.gte_),
  PROTOBUF_FIELD_OFFSET(::validate::SFixed64Rules, _impl_.in_),
  PROTOBUF_FIELD_OFFSET(::validate::SFixed64Rules, _impl_.not_in_),
  PROTOBUF_FIELD_OFFSET(::validate::SFixed64Rules, _impl_.ignore_empty_),
  0,
  1,
  2,
  3,
  4,
  ~0u,
  ~0u,
  5,
  PROTOBUF_FIELD_OFFSET(::validate::BoolRules, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::BoolRules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::validate::BoolRules, _impl_.const__),
  0,
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, _impl_.const__),
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, _impl_.len_),
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, _impl_.min_len_),
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, _impl_.max_len_),
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, _impl_.len_bytes_),
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, _impl_.min_bytes_),
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, _impl_.max_bytes_),
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, _impl_.pattern_),
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, _impl_.prefix_),
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, _impl_.suffix_),
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, _impl_.contains_),
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, _impl_.not_contains_),
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, _impl_.in_),
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, _impl_.not_in_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, _impl_.strict_),
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, _impl_.ignore_empty_),
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, _impl_.well_known_),
  0,
  10,
  6,
  7,
  11,
  8,
  9,
  1,
  2,
  3,
  4,
  5,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  13,
  12,
  PROTOBUF_FIELD_OFFSET(::validate::BytesRules, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::BytesRules, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::validate::BytesRules, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::validate::BytesRules, _impl_.const__),
  PROTOBUF_FIELD_OFFSET(::validate::BytesRules, _impl_.len_),
  PROTOBUF_FIELD_OFFSET(::validate::BytesRules, _impl_.min_len_),
  PROTOBUF_FIELD_OFFSET(::validate::BytesRules, _impl_.max_len_),
  PROTOBUF_FIELD_OFFSET(::validate::BytesRules, _impl_.pattern_),
  PROTOBUF_FIELD_OFFSET(::validate::BytesRules, _impl_.prefix_),
  PROTOBUF_FIELD_OFFSET(::validate::BytesRules, _impl_.suffix_),
  PROTOBUF_FIELD_OFFSET(::validate::BytesRules, _impl_.contains_),
  PROTOBUF_FIELD_OFFSET(::validate::BytesRules, _impl_.in_),
  PROTOBUF_FIELD_OFFSET(::validate::BytesRules, _impl_.not_in_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::validate::BytesRules, _impl_.ignore_empty_),
  PROTOBUF_FIELD_OFFSET(::validate::BytesRules, _impl_.well_known_),
  0,
  7,
  5,
  6,
  1,
  2,
  3,
  4,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  8,
  PROTOBUF_FIELD_OFFSET(::validate::EnumRules, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::EnumRules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::validate::EnumRules, _impl_.const__),
  PROTOBUF_FIELD_OFFSET(::validate::EnumRules, _impl_.defined_only_),
  PROTOBUF_FIELD_OFFSET(::validate::EnumRules, _impl_.in_),
  PROTOBUF_FIELD_OFFSET(::validate::EnumRules, _impl_.not_in_),
  0,
  1,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::validate::MessageRules, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::MessageRules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::validate::MessageRules, _impl_.skip_),
  PROTOBUF_FIELD_OFFSET(::validate::MessageRules, _impl_.required_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::validate::RepeatedRules, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::RepeatedRules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::validate::RepeatedRules, _impl_.min_items_),
  PROTOBUF_FIELD_OFFSET(::validate::RepeatedRules, _impl_.max_items_),
  PROTOBUF_FIELD_OFFSET(::validate::RepeatedRules, _impl_.unique_),
  PROTOBUF_FIELD_OFFSET(::validate::RepeatedRules, _impl_.items_),
  PROTOBUF_FIELD_OFFSET(::validate::RepeatedRules, _impl_.ignore_empty_),
  1,
  2,
  3,
  0,
  4,
  PROTOBUF_FIELD_OFFSET(::validate::MapRules, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::MapRules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::validate::MapRules, _impl_.min_pairs_),
  PROTOBUF_FIELD_OFFSET(::validate::MapRules, _impl_.max_pairs_),
  PROTOBUF_FIELD_OFFSET(::validate::MapRules, _impl_.no_sparse_),
  PROTOBUF_FIELD_OFFSET(::validate::MapRules, _impl_.keys_),
  PROTOBUF_FIELD_OFFSET(::validate::MapRules, _impl_.values_),
  PROTOBUF_FIELD_OFFSET(::validate::MapRules, _impl_.ignore_empty_),
  2,
  3,
  4,
  0,
  1,
  5,
  PROTOBUF_FIELD_OFFSET(::validate::AnyRules, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::AnyRules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::validate::AnyRules, _impl_.required_),
  PROTOBUF_FIELD_OFFSET(::validate::AnyRules, _impl_.in_),
  PROTOBUF_FIELD_OFFSET(::validate::AnyRules, _impl_.not_in_),
  0,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::validate::DurationRules, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::DurationRules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::validate::DurationRules, _impl_.required_),
  PROTOBUF_FIELD_OFFSET(::validate::DurationRules, _impl_.const__),
  PROTOBUF_FIELD_OFFSET(::validate::DurationRules, _impl_.lt_),
  PROTOBUF_FIELD_OFFSET(::validate::DurationRules, _impl_.lte_),
  PROTOBUF_FIELD_OFFSET(::validate::DurationRules, _impl_.gt_),
  PROTOBUF_FIELD_OFFSET(::validate::DurationRules, _impl_.gte_),
  PROTOBUF_FIELD_OFFSET(::validate::DurationRules, _impl_.in_),
  PROTOBUF_FIELD_OFFSET(::validate::DurationRules, _impl_.not_in_),
  5,
  0,
  1,
  2,
  3,
  4,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::validate::TimestampRules, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::TimestampRules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::validate::TimestampRules, _impl_.required_),
  PROTOBUF_FIELD_OFFSET(::validate::TimestampRules, _impl_.const__),
  PROTOBUF_FIELD_OFFSET(::validate::TimestampRules, _impl_.lt_),
  PROTOBUF_FIELD_OFFSET(::validate::TimestampRules, _impl_.lte_),
  PROTOBUF_FIELD_OFFSET(::validate::TimestampRules, _impl_.gt_),
  PROTOBUF_FIELD_OFFSET(::validate::TimestampRules, _impl_.gte_),
  PROTOBUF_FIELD_OFFSET(::validate::TimestampRules, _impl_.lt_now_),
  PROTOBUF_FIELD_OFFSET(::validate::TimestampRules, _impl_.gt_now_),
  PROTOBUF_FIELD_OFFSET(::validate::TimestampRules, _impl_.within_),
  6,
  0,
  1,
  2,
  3,
  4,
  7,
  8,
  5,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 29, -1, sizeof(::validate::FieldRules)},
  { 51, 65, -1, sizeof(::validate::FloatRules)},
  { 73, 87, -1, sizeof(::validate::DoubleRules)},
  { 95, 109, -1, sizeof(::validate::Int32Rules)},
  { 117, 131, -1, sizeof(::validate::Int64Rules)},
  { 139, 153, -1, sizeof(::validate::UInt32Rules)},
  { 161, 175, -1, sizeof(::validate::UInt64Rules)},
  { 183, 197, -1, sizeof(::validate::SInt32Rules)},
  { 205, 219, -1, sizeof(::validate::SInt64Rules)},
  { 227, 241, -1, sizeof(::validate::Fixed32Rules)},
  { 249, 263, -1, sizeof(::validate::Fixed64Rules)},
  { 271, 285, -1, sizeof(::validate::SFixed32Rules)},
  { 293, 307, -1, sizeof(::validate::SFixed64Rules)},
  { 315, 322, -1, sizeof(::validate::BoolRules)},
  { 323, 356, -1, sizeof(::validate::StringRules)},
  { 382, 403, -1, sizeof(::validate::BytesRules)},
  { 417, 427, -1, sizeof(::validate::EnumRules)},
  { 431, 439, -1, sizeof(::validate::MessageRules)},
  { 441, 452, -1, sizeof(::validate::RepeatedRules)},
  { 457, 469, -1, sizeof(::validate::MapRules)},
  { 475, 484, -1, sizeof(::validate::AnyRules)},
  { 487, 501, -1, sizeof(::validate::DurationRules)},
  { 509, 524, -1, sizeof(::validate::TimestampRules)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::validate::_FieldRules_default_instance_._instance,
  &::validate::_FloatRules_default_instance_._instance,
  &::validate::_DoubleRules_default_instance_._instance,
  &::validate::_Int32Rules_default_instance_._instance,
  &::validate::_Int64Rules_default_instance_._instance,
  &::validate::_UInt32Rules_default_instance_._instance,
  &::validate::_UInt64Rules_default_instance_._instance,
  &::validate::_SInt32Rules_default_instance_._instance,
  &::validate::_SInt64Rules_default_instance_._instance,
  &::validate::_Fixed32Rules_default_instance_._instance,
  &::validate::_Fixed64Rules_default_instance_._instance,
  &::validate::_SFixed32Rules_default_instance_._instance,
  &::validate::_SFixed64Rules_default_instance_._instance,
  &::validate::_BoolRules_default_instance_._instance,
  &::validate::_StringRules_default_instance_._instance,
  &::validate::_BytesRules_default_instance_._instance,
  &::validate::_EnumRules_default_instance_._instance,
  &::validate::_MessageRules_default_instance_._instance,
  &::validate::_RepeatedRules_default_instance_._instance,
  &::validate::_MapRules_default_instance_._instance,
  &::validate::_AnyRules_default_instance_._instance,
  &::validate::_DurationRules_default_instance_._instance,
  &::validate::_TimestampRules_default_instance_._instance,
};

const char descriptor_table_protodef_validate_2fvalidate_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\027validate/validate.proto\022\010validate\032 goo"
  "gle/protobuf/descriptor.proto\032\036google/pr"
  "otobuf/duration.proto\032\037google/protobuf/t"
  "imestamp.proto\"\310\010\n\nFieldRules\0220\n\007message"
  "\030\021 \001(\0132\026.validate.MessageRulesR\007message\022"
  ",\n\005float\030\001 \001(\0132\024.validate.FloatRulesH\000R\005"
  "float\022/\n\006double\030\002 \001(\0132\025.validate.DoubleR"
  "ulesH\000R\006double\022,\n\005int32\030\003 \001(\0132\024.validate"
  ".Int32RulesH\000R\005int32\022,\n\005int64\030\004 \001(\0132\024.va"
  "lidate.Int64RulesH\000R\005int64\022/\n\006uint32\030\005 \001"
  "(\0132\025.validate.UInt32RulesH\000R\006uint32\022/\n\006u"
  "int64\030\006 \001(\0132\025.validate.UInt64RulesH\000R\006ui"
  "nt64\022/\n\006sint32\030\007 \001(\0132\025.validate.SInt32Ru"
  "lesH\000R\006sint32\022/\n\006sint64\030\010 \001(\0132\025.validate"
  ".SInt64RulesH\000R\006sint64\0222\n\007fixed32\030\t \001(\0132"
  "\026.validate.Fixed32RulesH\000R\007fixed32\0222\n\007fi"
  "xed64\030\n \001(\0132\026.validate.Fixed64RulesH\000R\007f"
  "ixed64\0225\n\010sfixed32\030\013 \001(\0132\027.validate.SFix"
  "ed32RulesH\000R\010sfixed32\0225\n\010sfixed64\030\014 \001(\0132"
  "\027.validate.SFixed64RulesH\000R\010sfixed64\022)\n\004"
  "bool\030\r \001(\0132\023.validate.BoolRulesH\000R\004bool\022"
  "/\n\006string\030\016 \001(\0132\025.validate.StringRulesH\000"
  "R\006string\022,\n\005bytes\030\017 \001(\0132\024.validate.Bytes"
  "RulesH\000R\005bytes\022)\n\004enum\030\020 \001(\0132\023.validate."
  "EnumRulesH\000R\004enum\0225\n\010repeated\030\022 \001(\0132\027.va"
  "lidate.RepeatedRulesH\000R\010repeated\022&\n\003map\030"
  "\023 \001(\0132\022.validate.MapRulesH\000R\003map\022&\n\003any\030"
  "\024 \001(\0132\022.validate.AnyRulesH\000R\003any\0225\n\010dura"
  "tion\030\025 \001(\0132\027.validate.DurationRulesH\000R\010d"
  "uration\0228\n\ttimestamp\030\026 \001(\0132\030.validate.Ti"
  "mestampRulesH\000R\ttimestampB\006\n\004type\"\260\001\n\nFl"
  "oatRules\022\024\n\005const\030\001 \001(\002R\005const\022\016\n\002lt\030\002 \001"
  "(\002R\002lt\022\020\n\003lte\030\003 \001(\002R\003lte\022\016\n\002gt\030\004 \001(\002R\002gt"
  "\022\020\n\003gte\030\005 \001(\002R\003gte\022\016\n\002in\030\006 \003(\002R\002in\022\025\n\006no"
  "t_in\030\007 \003(\002R\005notIn\022!\n\014ignore_empty\030\010 \001(\010R"
  "\013ignoreEmpty\"\261\001\n\013DoubleRules\022\024\n\005const\030\001 "
  "\001(\001R\005const\022\016\n\002lt\030\002 \001(\001R\002lt\022\020\n\003lte\030\003 \001(\001R"
  "\003lte\022\016\n\002gt\030\004 \001(\001R\002gt\022\020\n\003gte\030\005 \001(\001R\003gte\022\016"
  "\n\002in\030\006 \003(\001R\002in\022\025\n\006not_in\030\007 \003(\001R\005notIn\022!\n"
  "\014ignore_empty\030\010 \001(\010R\013ignoreEmpty\"\260\001\n\nInt"
  "32Rules\022\024\n\005const\030\001 \001(\005R\005const\022\016\n\002lt\030\002 \001("
  "\005R\002lt\022\020\n\003lte\030\003 \001(\005R\003lte\022\016\n\002gt\030\004 \001(\005R\002gt\022"
  "\020\n\003gte\030\005 \001(\005R\003gte\022\016\n\002in\030\006 \003(\005R\002in\022\025\n\006not"
  "_in\030\007 \003(\005R\005notIn\022!\n\014ignore_empty\030\010 \001(\010R\013"
  "ignoreEmpty\"\260\001\n\nInt64Rules\022\024\n\005const\030\001 \001("
  "\003R\005const\022\016\n\002lt\030\002 \001(\003R\002lt\022\020\n\003lte\030\003 \001(\003R\003l"
  "te\022\016\n\002gt\030\004 \001(\003R\002gt\022\020\n\003gte\030\005 \001(\003R\003gte\022\016\n\002"
  "in\030\006 \003(\003R\002in\022\025\n\006not_in\030\007 \003(\003R\005notIn\022!\n\014i"
  "gnore_empty\030\010 \001(\010R\013ignoreEmpty\"\261\001\n\013UInt3"
  "2Rules\022\024\n\005const\030\001 \001(\rR\005const\022\016\n\002lt\030\002 \001(\r"
  "R\002lt\022\020\n\003lte\030\003 \001(\rR\003lte\022\016\n\002gt\030\004 \001(\rR\002gt\022\020"
  "\n\003gte\030\005 \001(\rR\003gte\022\016\n\002in\030\006 \003(\rR\002in\022\025\n\006not_"
  "in\030\007 \003(\rR\005notIn\022!\n\014ignore_empty\030\010 \001(\010R\013i"
  "gnoreEmpty\"\261\001\n\013UInt64Rules\022\024\n\005const\030\001 \001("
  "\004R\005const\022\016\n\002lt\030\002 \001(\004R\002lt\022\020\n\003lte\030\003 \001(\004R\003l"
  "te\022\016\n\002gt\030\004 \001(\004R\002gt\022\020\n\003gte\030\005 \001(\004R\003gte\022\016\n\002"
  "in\030\006 \003(\004R\002in\022\025\n\006not_in\030\007 \003(\004R\005notIn\022!\n\014i"
  "gnore_empty\030\010 \001(\010R\013ignoreEmpty\"\261\001\n\013SInt3"
  "2Rules\022\024\n\005const\030\001 \001(\021R\005const\022\016\n\002lt\030\002 \001(\021"
  "R\002lt\022\020\n\003lte\030\003 \001(\021R\003lte\022\016\n\002gt\030\004 \001(\021R\002gt\022\020"
  "\n\003gte\030\005 \001(\021R\003gte\022\016\n\002in\030\006 \003(\021R\002in\022\025\n\006not_"
  "in\030\007 \003(\021R\005notIn\022!\n\014ignore_empty\030\010 \001(\010R\013i"
  "gnoreEmpty\"\261\001\n\013SInt64Rules\022\024\n\005const\030\001 \001("
  "\022R\005const\022\016\n\002lt\030\002 \001(\022R\002lt\022\020\n\003lte\030\003 \001(\022R\003l"
  "te\022\016\n\002gt\030\004 \001(\022R\002gt\022\020\n\003gte\030\005 \001(\022R\003gte\022\016\n\002"
  "in\030\006 \003(\022R\002in\022\025\n\006not_in\030\007 \003(\022R\005notIn\022!\n\014i"
  "gnore_empty\030\010 \001(\010R\013ignoreEmpty\"\262\001\n\014Fixed"
  "32Rules\022\024\n\005const\030\001 \001(\007R\005const\022\016\n\002lt\030\002 \001("
  "\007R\002lt\022\020\n\003lte\030\003 \001(\007R\003lte\022\016\n\002gt\030\004 \001(\007R\002gt\022"
  "\020\n\003gte\030\005 \001(\007R\003gte\022\016\n\002in\030\006 \003(\007R\002in\022\025\n\006not"
  "_in\030\007 \003(\007R\005notIn\022!\n\014ignore_empty\030\010 \001(\010R\013"
  "ignoreEmpty\"\262\001\n\014Fixed64Rules\022\024\n\005const\030\001 "
  "\001(\006R\005const\022\016\n\002lt\030\002 \001(\006R\002lt\022\020\n\003lte\030\003 \001(\006R"
  "\003lte\022\016\n\002gt\030\004 \001(\006R\002gt\022\020\n\003gte\030\005 \001(\006R\003gte\022\016"
  "\n\002in\030\006 \003(\006R\002in\022\025\n\006not_in\030\007 \003(\006R\005notIn\022!\n"
  "\014ignore_empty\030\010 \001(\010R\013ignoreEmpty\"\263\001\n\rSFi"
  "xed32Rules\022\024\n\005const\030\001 \001(\017R\005const\022\016\n\002lt\030\002"
  " \001(\017R\002lt\022\020\n\003lte\030\003 \001(\017R\003lte\022\016\n\002gt\030\004 \001(\017R\002"
  "gt\022\020\n\003gte\030\005 \001(\017R\003gte\022\016\n\002in\030\006 \003(\017R\002in\022\025\n\006"
  "not_in\030\007 \003(\017R\005notIn\022!\n\014ignore_empty\030\010 \001("
  "\010R\013ignoreEmpty\"\263\001\n\rSFixed64Rules\022\024\n\005cons"
  "t\030\001 \001(\020R\005const\022\016\n\002lt\030\002 \001(\020R\002lt\022\020\n\003lte\030\003 "
  "\001(\020R\003lte\022\016\n\002gt\030\004 \001(\020R\002gt\022\020\n\003gte\030\005 \001(\020R\003g"
  "te\022\016\n\002in\030\006 \003(\020R\002in\022\025\n\006not_in\030\007 \003(\020R\005notI"
  "n\022!\n\014ignore_empty\030\010 \001(\010R\013ignoreEmpty\"!\n\t"
  "BoolRules\022\024\n\005const\030\001 \001(\010R\005const\"\324\005\n\013Stri"
  "ngRules\022\024\n\005const\030\001 \001(\tR\005const\022\020\n\003len\030\023 \001"
  "(\004R\003len\022\027\n\007min_len\030\002 \001(\004R\006minLen\022\027\n\007max_"
  "len\030\003 \001(\004R\006maxLen\022\033\n\tlen_bytes\030\024 \001(\004R\010le"
  "nBytes\022\033\n\tmin_bytes\030\004 \001(\004R\010minBytes\022\033\n\tm"
  "ax_bytes\030\005 \001(\004R\010maxBytes\022\030\n\007pattern\030\006 \001("
  "\tR\007pattern\022\026\n\006prefix\030\007 \001(\tR\006prefix\022\026\n\006su"
  "ffix\030\010 \001(\tR\006suffix\022\032\n\010contains\030\t \001(\tR\010co"
  "ntains\022!\n\014not_contains\030\027 \001(\tR\013notContain"
  "s\022\016\n\002in\030\n \003(\tR\002in\022\025\n\006not_in\030\013 \003(\tR\005notIn"
  "\022\026\n\005email\030\014 \001(\010H\000R\005email\022\034\n\010hostname\030\r \001"
  "(\010H\000R\010hostname\022\020\n\002ip\030\016 \001(\010H\000R\002ip\022\024\n\004ipv4"
  "\030\017 \001(\010H\000R\004ipv4\022\024\n\004ipv6\030\020 \001(\010H\000R\004ipv6\022\022\n\003"
  "uri\030\021 \001(\010H\000R\003uri\022\031\n\007uri_ref\030\022 \001(\010H\000R\006uri"
  "Ref\022\032\n\007address\030\025 \001(\010H\000R\007address\022\024\n\004uuid\030"
  "\026 \001(\010H\000R\004uuid\022@\n\020well_known_regex\030\030 \001(\0162"
  "\024.validate.KnownRegexH\000R\016wellKnownRegex\022"
  "\034\n\006strict\030\031 \001(\010:\004trueR\006strict\022!\n\014ignore_"
  "empty\030\032 \001(\010R\013ignoreEmptyB\014\n\nwell_known\"\342"
  "\002\n\nBytesRules\022\024\n\005const\030\001 \001(\014R\005const\022\020\n\003l"
  "en\030\r \001(\004R\003len\022\027\n\007min_len\030\002 \001(\004R\006minLen\022\027"
  "\n\007max_len\030\003 \001(\004R\006maxLen\022\030\n\007pattern\030\004 \001(\t"
  "R\007pattern\022\026\n\006prefix\030\005 \001(\014R\006prefix\022\026\n\006suf"
  "fix\030\006 \001(\014R\006suffix\022\032\n\010contains\030\007 \001(\014R\010con"
  "tains\022\016\n\002in\030\010 \003(\014R\002in\022\025\n\006not_in\030\t \003(\014R\005n"
  "otIn\022\020\n\002ip\030\n \001(\010H\000R\002ip\022\024\n\004ipv4\030\013 \001(\010H\000R\004"
  "ipv4\022\024\n\004ipv6\030\014 \001(\010H\000R\004ipv6\022!\n\014ignore_emp"
  "ty\030\016 \001(\010R\013ignoreEmptyB\014\n\nwell_known\"k\n\tE"
  "numRules\022\024\n\005const\030\001 \001(\005R\005const\022!\n\014define"
  "d_only\030\002 \001(\010R\013definedOnly\022\016\n\002in\030\003 \003(\005R\002i"
  "n\022\025\n\006not_in\030\004 \003(\005R\005notIn\">\n\014MessageRules"
  "\022\022\n\004skip\030\001 \001(\010R\004skip\022\032\n\010required\030\002 \001(\010R\010"
  "required\"\260\001\n\rRepeatedRules\022\033\n\tmin_items\030"
  "\001 \001(\004R\010minItems\022\033\n\tmax_items\030\002 \001(\004R\010maxI"
  "tems\022\026\n\006unique\030\003 \001(\010R\006unique\022*\n\005items\030\004 "
  "\001(\0132\024.validate.FieldRulesR\005items\022!\n\014igno"
  "re_empty\030\005 \001(\010R\013ignoreEmpty\"\334\001\n\010MapRules"
  "\022\033\n\tmin_pairs\030\001 \001(\004R\010minPairs\022\033\n\tmax_pai"
  "rs\030\002 \001(\004R\010maxPairs\022\033\n\tno_sparse\030\003 \001(\010R\010n"
  "oSparse\022(\n\004keys\030\004 \001(\0132\024.validate.FieldRu"
  "lesR\004keys\022,\n\006values\030\005 \001(\0132\024.validate.Fie"
  "ldRulesR\006values\022!\n\014ignore_empty\030\006 \001(\010R\013i"
  "gnoreEmpty\"M\n\010AnyRules\022\032\n\010required\030\001 \001(\010"
  "R\010required\022\016\n\002in\030\002 \003(\tR\002in\022\025\n\006not_in\030\003 \003"
  "(\tR\005notIn\"\351\002\n\rDurationRules\022\032\n\010required\030"
  "\001 \001(\010R\010required\022/\n\005const\030\002 \001(\0132\031.google."
  "protobuf.DurationR\005const\022)\n\002lt\030\003 \001(\0132\031.g"
  "oogle.protobuf.DurationR\002lt\022+\n\003lte\030\004 \001(\013"
  "2\031.google.protobuf.DurationR\003lte\022)\n\002gt\030\005"
  " \001(\0132\031.google.protobuf.DurationR\002gt\022+\n\003g"
  "te\030\006 \001(\0132\031.google.protobuf.DurationR\003gte"
  "\022)\n\002in\030\007 \003(\0132\031.google.protobuf.DurationR"
  "\002in\0220\n\006not_in\030\010 \003(\0132\031.google.protobuf.Du"
  "rationR\005notIn\"\363\002\n\016TimestampRules\022\032\n\010requ"
  "ired\030\001 \001(\010R\010required\0220\n\005const\030\002 \001(\0132\032.go"
  "ogle.protobuf.TimestampR\005const\022*\n\002lt\030\003 \001"
  "(\0132\032.google.protobuf.TimestampR\002lt\022,\n\003lt"
  "e\030\004 \001(\0132\032.google.protobuf.TimestampR\003lte"
  "\022*\n\002gt\030\005 \001(\0132\032.google.protobuf.Timestamp"
  "R\002gt\022,\n\003gte\030\006 \001(\0132\032.google.protobuf.Time"
  "stampR\003gte\022\025\n\006lt_now\030\007 \001(\010R\005ltNow\022\025\n\006gt_"
  "now\030\010 \001(\010R\005gtNow\0221\n\006within\030\t \001(\0132\031.googl"
  "e.protobuf.DurationR\006within*F\n\nKnownRege"
  "x\022\013\n\007UNKNOWN\020\000\022\024\n\020HTTP_HEADER_NAME\020\001\022\025\n\021"
  "HTTP_HEADER_VALUE\020\002:<\n\010disabled\022\037.google"
  ".protobuf.MessageOptions\030\257\010 \001(\010R\010disable"
  "d::\n\007ignored\022\037.google.protobuf.MessageOp"
  "tions\030\260\010 \001(\010R\007ignored::\n\010required\022\035.goog"
  "le.protobuf.OneofOptions\030\257\010 \001(\010R\010require"
  "d:J\n\005rules\022\035.google.protobuf.FieldOption"
  "s\030\257\010 \001(\0132\024.validate.FieldRulesR\005rulesBP\n"
  "\032io.envoyproxy.pgv.validateZ2github.com/"
  "envoyproxy/protoc-gen-validate/validate"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_validate_2fvalidate_2eproto_deps[3] = {
  &::descriptor_table_google_2fprotobuf_2fdescriptor_2eproto,
  &::descriptor_table_google_2fprotobuf_2fduration_2eproto,
  &::descriptor_table_google_2fprotobuf_2ftimestamp_2eproto,
};
static ::_pbi::once_flag descriptor_table_validate_2fvalidate_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_validate_2fvalidate_2eproto = {
    false, false, 6319, descriptor_table_protodef_validate_2fvalidate_2eproto,
    "validate/validate.proto",
    &descriptor_table_validate_2fvalidate_2eproto_once, descriptor_table_validate_2fvalidate_2eproto_deps, 3, 23,
    schemas, file_default_instances, TableStruct_validate_2fvalidate_2eproto::offsets,
    file_level_metadata_validate_2fvalidate_2eproto, file_level_enum_descriptors_validate_2fvalidate_2eproto,
    file_level_service_descriptors_validate_2fvalidate_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_validate_2fvalidate_2eproto_getter() {
  return &descriptor_table_validate_2fvalidate_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_validate_2fvalidate_2eproto(&descriptor_table_validate_2fvalidate_2eproto);
namespace validate {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* KnownRegex_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_validate_2fvalidate_2eproto);
  return file_level_enum_descriptors_validate_2fvalidate_2eproto[0];
}
bool KnownRegex_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class FieldRules::_Internal {
 public:
  using HasBits = decltype(std::declval<FieldRules>()._impl_._has_bits_);
  static const ::validate::MessageRules& message(const FieldRules* msg);
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::validate::FloatRules& float_(const FieldRules* msg);
  static const ::validate::DoubleRules& double_(const FieldRules* msg);
  static const ::validate::Int32Rules& int32(const FieldRules* msg);
  static const ::validate::Int64Rules& int64(const FieldRules* msg);
  static const ::validate::UInt32Rules& uint32(const FieldRules* msg);
  static const ::validate::UInt64Rules& uint64(const FieldRules* msg);
  static const ::validate::SInt32Rules& sint32(const FieldRules* msg);
  static const ::validate::SInt64Rules& sint64(const FieldRules* msg);
  static const ::validate::Fixed32Rules& fixed32(const FieldRules* msg);
  static const ::validate::Fixed64Rules& fixed64(const FieldRules* msg);
  static const ::validate::SFixed32Rules& sfixed32(const FieldRules* msg);
  static const ::validate::SFixed64Rules& sfixed64(const FieldRules* msg);
  static const ::validate::BoolRules& bool_(const FieldRules* msg);
  static const ::validate::StringRules& string(const FieldRules* msg);
  static const ::validate::BytesRules& bytes(const FieldRules* msg);
  static const ::validate::EnumRules& enum_(const FieldRules* msg);
  static const ::validate::RepeatedRules& repeated(const FieldRules* msg);
  static const ::validate::MapRules& map(const FieldRules* msg);
  static const ::validate::AnyRules& any(const FieldRules* msg);
  static const ::validate::DurationRules& duration(const FieldRules* msg);
  static const ::validate::TimestampRules& timestamp(const FieldRules* msg);
};

const ::validate::MessageRules&
FieldRules::_Internal::message(const FieldRules* msg) {
  return *msg->_impl_.message_;
}
const ::validate::FloatRules&
FieldRules::_Internal::float_(const FieldRules* msg) {
  return *msg->_impl_.type_.float__;
}
const ::validate::DoubleRules&
FieldRules::_Internal::double_(const FieldRules* msg) {
  return *msg->_impl_.type_.double__;
}
const ::validate::Int32Rules&
FieldRules::_Internal::int32(const FieldRules* msg) {
  return *msg->_impl_.type_.int32_;
}
const ::validate::Int64Rules&
FieldRules::_Internal::int64(const FieldRules* msg) {
  return *msg->_impl_.type_.int64_;
}
const ::validate::UInt32Rules&
FieldRules::_Internal::uint32(const FieldRules* msg) {
  return *msg->_impl_.type_.uint32_;
}
const ::validate::UInt64Rules&
FieldRules::_Internal::uint64(const FieldRules* msg) {
  return *msg->_impl_.type_.uint64_;
}
const ::validate::SInt32Rules&
FieldRules::_Internal::sint32(const FieldRules* msg) {
  return *msg->_impl_.type_.sint32_;
}
const ::validate::SInt64Rules&
FieldRules::_Internal::sint64(const FieldRules* msg) {
  return *msg->_impl_.type_.sint64_;
}
const ::validate::Fixed32Rules&
FieldRules::_Internal::fixed32(const FieldRules* msg) {
  return *msg->_impl_.type_.fixed32_;
}
const ::validate::Fixed64Rules&
FieldRules::_Internal::fixed64(const FieldRules* msg) {
  return *msg->_impl_.type_.fixed64_;
}
const ::validate::SFixed32Rules&
FieldRules::_Internal::sfixed32(const FieldRules* msg) {
  return *msg->_impl_.type_.sfixed32_;
}
const ::validate::SFixed64Rules&
FieldRules::_Internal::sfixed64(const FieldRules* msg) {
  return *msg->_impl_.type_.sfixed64_;
}
const ::validate::BoolRules&
FieldRules::_Internal::bool_(const FieldRules* msg) {
  return *msg->_impl_.type_.bool__;
}
const ::validate::StringRules&
FieldRules::_Internal::string(const FieldRules* msg) {
  return *msg->_impl_.type_.string_;
}
const ::validate::BytesRules&
FieldRules::_Internal::bytes(const FieldRules* msg) {
  return *msg->_impl_.type_.bytes_;
}
const ::validate::EnumRules&
FieldRules::_Internal::enum_(const FieldRules* msg) {
  return *msg->_impl_.type_.enum__;
}
const ::validate::RepeatedRules&
FieldRules::_Internal::repeated(const FieldRules* msg) {
  return *msg->_impl_.type_.repeated_;
}
const ::validate::MapRules&
FieldRules::_Internal::map(const FieldRules* msg) {
  return *msg->_impl_.type_.map_;
}
const ::validate::AnyRules&
FieldRules::_Internal::any(const FieldRules* msg) {
  return *msg->_impl_.type_.any_;
}
const ::validate::DurationRules&
FieldRules::_Internal::duration(const FieldRules* msg) {
  return *msg->_impl_.type_.duration_;
}
const ::validate::TimestampRules&
FieldRules::_Internal::timestamp(const FieldRules* msg) {
  return *msg->_impl_.type_.timestamp_;
}
void FieldRules::set_allocated_float_(::validate::FloatRules* float_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (float_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(float_);
    if (message_arena != submessage_arena) {
      float_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, float_, submessage_arena);
    }
    set_has_float_();
    _impl_.type_.float__ = float_;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.float)
}
void FieldRules::set_allocated_double_(::validate::DoubleRules* double_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (double_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(double_);
    if (message_arena != submessage_arena) {
      double_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, double_, submessage_arena);
    }
    set_has_double_();
    _impl_.type_.double__ = double_;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.double)
}
void FieldRules::set_allocated_int32(::validate::Int32Rules* int32) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (int32) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(int32);
    if (message_arena != submessage_arena) {
      int32 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, int32, submessage_arena);
    }
    set_has_int32();
    _impl_.type_.int32_ = int32;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.int32)
}
void FieldRules::set_allocated_int64(::validate::Int64Rules* int64) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (int64) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(int64);
    if (message_arena != submessage_arena) {
      int64 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, int64, submessage_arena);
    }
    set_has_int64();
    _impl_.type_.int64_ = int64;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.int64)
}
void FieldRules::set_allocated_uint32(::validate::UInt32Rules* uint32) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (uint32) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(uint32);
    if (message_arena != submessage_arena) {
      uint32 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, uint32, submessage_arena);
    }
    set_has_uint32();
    _impl_.type_.uint32_ = uint32;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.uint32)
}
void FieldRules::set_allocated_uint64(::validate::UInt64Rules* uint64) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (uint64) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(uint64);
    if (message_arena != submessage_arena) {
      uint64 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, uint64, submessage_arena);
    }
    set_has_uint64();
    _impl_.type_.uint64_ = uint64;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.uint64)
}
void FieldRules::set_allocated_sint32(::validate::SInt32Rules* sint32) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (sint32) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sint32);
    if (message_arena != submessage_arena) {
      sint32 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sint32, submessage_arena);
    }
    set_has_sint32();
    _impl_.type_.sint32_ = sint32;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.sint32)
}
void FieldRules::set_allocated_sint64(::validate::SInt64Rules* sint64) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (sint64) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sint64);
    if (message_arena != submessage_arena) {
      sint64 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sint64, submessage_arena);
    }
    set_has_sint64();
    _impl_.type_.sint64_ = sint64;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.sint64)
}
void FieldRules::set_allocated_fixed32(::validate::Fixed32Rules* fixed32) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (fixed32) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fixed32);
    if (message_arena != submessage_arena) {
      fixed32 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fixed32, submessage_arena);
    }
    set_has_fixed32();
    _impl_.type_.fixed32_ = fixed32;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.fixed32)
}
void FieldRules::set_allocated_fixed64(::validate::Fixed64Rules* fixed64) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (fixed64) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fixed64);
    if (message_arena != submessage_arena) {
      fixed64 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fixed64, submessage_arena);
    }
    set_has_fixed64();
    _impl_.type_.fixed64_ = fixed64;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.fixed64)
}
void FieldRules::set_allocated_sfixed32(::validate::SFixed32Rules* sfixed32) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (sfixed32) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sfixed32);
    if (message_arena != submessage_arena) {
      sfixed32 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sfixed32, submessage_arena);
    }
    set_has_sfixed32();
    _impl_.type_.sfixed32_ = sfixed32;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.sfixed32)
}
void FieldRules::set_allocated_sfixed64(::validate::SFixed64Rules* sfixed64) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (sfixed64) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sfixed64);
    if (message_arena != submessage_arena) {
      sfixed64 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sfixed64, submessage_arena);
    }
    set_has_sfixed64();
    _impl_.type_.sfixed64_ = sfixed64;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.sfixed64)
}
void FieldRules::set_allocated_bool_(::validate::BoolRules* bool_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (bool_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bool_);
    if (message_arena != submessage_arena) {
      bool_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bool_, submessage_arena);
    }
    set_has_bool_();
    _impl_.type_.bool__ = bool_;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.bool)
}
void FieldRules::set_allocated_string(::validate::StringRules* string) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (string) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(string);
    if (message_arena != submessage_arena) {
      string = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, string, submessage_arena);
    }
    set_has_string();
    _impl_.type_.string_ = string;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.string)
}
void FieldRules::set_allocated_bytes(::validate::BytesRules* bytes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (bytes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bytes);
    if (message_arena != submessage_arena) {
      bytes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bytes, submessage_arena);
    }
    set_has_bytes();
    _impl_.type_.bytes_ = bytes;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.bytes)
}
void FieldRules::set_allocated_enum_(::validate::EnumRules* enum_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (enum_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(enum_);
    if (message_arena != submessage_arena) {
      enum_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, enum_, submessage_arena);
    }
    set_has_enum_();
    _impl_.type_.enum__ = enum_;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.enum)
}
void FieldRules::set_allocated_repeated(::validate::RepeatedRules* repeated) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (repeated) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(repeated);
    if (message_arena != submessage_arena) {
      repeated = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, repeated, submessage_arena);
    }
    set_has_repeated();
    _impl_.type_.repeated_ = repeated;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.repeated)
}
void FieldRules::set_allocated_map(::validate::MapRules* map) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (map) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(map);
    if (message_arena != submessage_arena) {
      map = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, map, submessage_arena);
    }
    set_has_map();
    _impl_.type_.map_ = map;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.map)
}
void FieldRules::set_allocated_any(::validate::AnyRules* any) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (any) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(any);
    if (message_arena != submessage_arena) {
      any = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, any, submessage_arena);
    }
    set_has_any();
    _impl_.type_.any_ = any;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.any)
}
void FieldRules::set_allocated_duration(::validate::DurationRules* duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(duration);
    if (message_arena != submessage_arena) {
      duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, duration, submessage_arena);
    }
    set_has_duration();
    _impl_.type_.duration_ = duration;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.duration)
}
void FieldRules::set_allocated_timestamp(::validate::TimestampRules* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(timestamp);
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    set_has_timestamp();
    _impl_.type_.timestamp_ = timestamp;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.timestamp)
}
FieldRules::FieldRules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:validate.FieldRules)
}
FieldRules::FieldRules(const FieldRules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FieldRules* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.message_){nullptr}
    , decltype(_impl_.type_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_message()) {
    _this->_impl_.message_ = new ::validate::MessageRules(*from._impl_.message_);
  }
  clear_has_type();
  switch (from.type_case()) {
    case kFloat: {
      _this->_internal_mutable_float_()->::validate::FloatRules::MergeFrom(
          from._internal_float_());
      break;
    }
    case kDouble: {
      _this->_internal_mutable_double_()->::validate::DoubleRules::MergeFrom(
          from._internal_double_());
      break;
    }
    case kInt32: {
      _this->_internal_mutable_int32()->::validate::Int32Rules::MergeFrom(
          from._internal_int32());
      break;
    }
    case kInt64: {
      _this->_internal_mutable_int64()->::validate::Int64Rules::MergeFrom(
          from._internal_int64());
      break;
    }
    case kUint32: {
      _this->_internal_mutable_uint32()->::validate::UInt32Rules::MergeFrom(
          from._internal_uint32());
      break;
    }
    case kUint64: {
      _this->_internal_mutable_uint64()->::validate::UInt64Rules::MergeFrom(
          from._internal_uint64());
      break;
    }
    case kSint32: {
      _this->_internal_mutable_sint32()->::validate::SInt32Rules::MergeFrom(
          from._internal_sint32());
      break;
    }
    case kSint64: {
      _this->_internal_mutable_sint64()->::validate::SInt64Rules::MergeFrom(
          from._internal_sint64());
      break;
    }
    case kFixed32: {
      _this->_internal_mutable_fixed32()->::validate::Fixed32Rules::MergeFrom(
          from._internal_fixed32());
      break;
    }
    case kFixed64: {
      _this->_internal_mutable_fixed64()->::validate::Fixed64Rules::MergeFrom(
          from._internal_fixed64());
      break;
    }
    case kSfixed32: {
      _this->_internal_mutable_sfixed32()->::validate::SFixed32Rules::MergeFrom(
          from._internal_sfixed32());
      break;
    }
    case kSfixed64: {
      _this->_internal_mutable_sfixed64()->::validate::SFixed64Rules::MergeFrom(
          from._internal_sfixed64());
      break;
    }
    case kBool: {
      _this->_internal_mutable_bool_()->::validate::BoolRules::MergeFrom(
          from._internal_bool_());
      break;
    }
    case kString: {
      _this->_internal_mutable_string()->::validate::StringRules::MergeFrom(
          from._internal_string());
      break;
    }
    case kBytes: {
      _this->_internal_mutable_bytes()->::validate::BytesRules::MergeFrom(
          from._internal_bytes());
      break;
    }
    case kEnum: {
      _this->_internal_mutable_enum_()->::validate::EnumRules::MergeFrom(
          from._internal_enum_());
      break;
    }
    case kRepeated: {
      _this->_internal_mutable_repeated()->::validate::RepeatedRules::MergeFrom(
          from._internal_repeated());
      break;
    }
    case kMap: {
      _this->_internal_mutable_map()->::validate::MapRules::MergeFrom(
          from._internal_map());
      break;
    }
    case kAny: {
      _this->_internal_mutable_any()->::validate::AnyRules::MergeFrom(
          from._internal_any());
      break;
    }
    case kDuration: {
      _this->_internal_mutable_duration()->::validate::DurationRules::MergeFrom(
          from._internal_duration());
      break;
    }
    case kTimestamp: {
      _this->_internal_mutable_timestamp()->::validate::TimestampRules::MergeFrom(
          from._internal_timestamp());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:validate.FieldRules)
}

inline void FieldRules::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.message_){nullptr}
    , decltype(_impl_.type_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_type();
}

FieldRules::~FieldRules() {
  // @@protoc_insertion_point(destructor:validate.FieldRules)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FieldRules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.message_;
  if (has_type()) {
    clear_type();
  }
}

void FieldRules::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FieldRules::clear_type() {
// @@protoc_insertion_point(one_of_clear_start:validate.FieldRules)
  switch (type_case()) {
    case kFloat: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.float__;
      }
      break;
    }
    case kDouble: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.double__;
      }
      break;
    }
    case kInt32: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.int32_;
      }
      break;
    }
    case kInt64: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.int64_;
      }
      break;
    }
    case kUint32: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.uint32_;
      }
      break;
    }
    case kUint64: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.uint64_;
      }
      break;
    }
    case kSint32: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.sint32_;
      }
      break;
    }
    case kSint64: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.sint64_;
      }
      break;
    }
    case kFixed32: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.fixed32_;
      }
      break;
    }
    case kFixed64: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.fixed64_;
      }
      break;
    }
    case kSfixed32: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.sfixed32_;
      }
      break;
    }
    case kSfixed64: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.sfixed64_;
      }
      break;
    }
    case kBool: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.bool__;
      }
      break;
    }
    case kString: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.string_;
      }
      break;
    }
    case kBytes: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.bytes_;
      }
      break;
    }
    case kEnum: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.enum__;
      }
      break;
    }
    case kRepeated: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.repeated_;
      }
      break;
    }
    case kMap: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.map_;
      }
      break;
    }
    case kAny: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.any_;
      }
      break;
    }
    case kDuration: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.duration_;
      }
      break;
    }
    case kTimestamp: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.timestamp_;
      }
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}


void FieldRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.FieldRules)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.message_ != nullptr);
    _impl_.message_->Clear();
  }
  clear_type();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FieldRules::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .validate.FloatRules float = 1 [json_name = "float"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_float_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .validate.DoubleRules double = 2 [json_name = "double"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_double_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .validate.Int32Rules int32 = 3 [json_name = "int32"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_int32(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .validate.Int64Rules int64 = 4 [json_name = "int64"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_int64(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .validate.UInt32Rules uint32 = 5 [json_name = "uint32"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_uint32(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .validate.UInt64Rules uint64 = 6 [json_name = "uint64"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_uint64(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .validate.SInt32Rules sint32 = 7 [json_name = "sint32"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_sint32(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .validate.SInt64Rules sint64 = 8 [json_name = "sint64"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_sint64(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .validate.Fixed32Rules fixed32 = 9 [json_name = "fixed32"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_fixed32(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .validate.Fixed64Rules fixed64 = 10 [json_name = "fixed64"];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_fixed64(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .validate.SFixed32Rules sfixed32 = 11 [json_name = "sfixed32"];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_sfixed32(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .validate.SFixed64Rules sfixed64 = 12 [json_name = "sfixed64"];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_sfixed64(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .validate.BoolRules bool = 13 [json_name = "bool"];
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_bool_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .validate.StringRules string = 14 [json_name = "string"];
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_string(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .validate.BytesRules bytes = 15 [json_name = "bytes"];
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_bytes(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .validate.EnumRules enum = 16 [json_name = "enum"];
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_enum_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .validate.MessageRules message = 17 [json_name = "message"];
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_message(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .validate.RepeatedRules repeated = 18 [json_name = "repeated"];
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_repeated(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .validate.MapRules map = 19 [json_name = "map"];
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .validate.AnyRules any = 20 [json_name = "any"];
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_any(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .validate.DurationRules duration = 21 [json_name = "duration"];
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_duration(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .validate.TimestampRules timestamp = 22 [json_name = "timestamp"];
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_timestamp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FieldRules::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.FieldRules)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (type_case()) {
    case kFloat: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::float_(this),
          _Internal::float_(this).GetCachedSize(), target, stream);
      break;
    }
    case kDouble: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::double_(this),
          _Internal::double_(this).GetCachedSize(), target, stream);
      break;
    }
    case kInt32: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::int32(this),
          _Internal::int32(this).GetCachedSize(), target, stream);
      break;
    }
    case kInt64: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::int64(this),
          _Internal::int64(this).GetCachedSize(), target, stream);
      break;
    }
    case kUint32: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::uint32(this),
          _Internal::uint32(this).GetCachedSize(), target, stream);
      break;
    }
    case kUint64: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, _Internal::uint64(this),
          _Internal::uint64(this).GetCachedSize(), target, stream);
      break;
    }
    case kSint32: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, _Internal::sint32(this),
          _Internal::sint32(this).GetCachedSize(), target, stream);
      break;
    }
    case kSint64: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, _Internal::sint64(this),
          _Internal::sint64(this).GetCachedSize(), target, stream);
      break;
    }
    case kFixed32: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, _Internal::fixed32(this),
          _Internal::fixed32(this).GetCachedSize(), target, stream);
      break;
    }
    case kFixed64: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, _Internal::fixed64(this),
          _Internal::fixed64(this).GetCachedSize(), target, stream);
      break;
    }
    case kSfixed32: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, _Internal::sfixed32(this),
          _Internal::sfixed32(this).GetCachedSize(), target, stream);
      break;
    }
    case kSfixed64: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(12, _Internal::sfixed64(this),
          _Internal::sfixed64(this).GetCachedSize(), target, stream);
      break;
    }
    case kBool: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(13, _Internal::bool_(this),
          _Internal::bool_(this).GetCachedSize(), target, stream);
      break;
    }
    case kString: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(14, _Internal::string(this),
          _Internal::string(this).GetCachedSize(), target, stream);
      break;
    }
    case kBytes: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(15, _Internal::bytes(this),
          _Internal::bytes(this).GetCachedSize(), target, stream);
      break;
    }
    case kEnum: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(16, _Internal::enum_(this),
          _Internal::enum_(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  cached_has_bits = _impl_._has_bits_[0];
  // optional .validate.MessageRules message = 17 [json_name = "message"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(17, _Internal::message(this),
        _Internal::message(this).GetCachedSize(), target, stream);
  }

  switch (type_case()) {
    case kRepeated: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(18, _Internal::repeated(this),
          _Internal::repeated(this).GetCachedSize(), target, stream);
      break;
    }
    case kMap: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(19, _Internal::map(this),
          _Internal::map(this).GetCachedSize(), target, stream);
      break;
    }
    case kAny: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(20, _Internal::any(this),
          _Internal::any(this).GetCachedSize(), target, stream);
      break;
    }
    case kDuration: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(21, _Internal::duration(this),
          _Internal::duration(this).GetCachedSize(), target, stream);
      break;
    }
    case kTimestamp: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(22, _Internal::timestamp(this),
          _Internal::timestamp(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.FieldRules)
  return target;
}

size_t FieldRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.FieldRules)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .validate.MessageRules message = 17 [json_name = "message"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.message_);
  }

  switch (type_case()) {
    // .validate.FloatRules float = 1 [json_name = "float"];
    case kFloat: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.type_.float__);
      break;
    }
    // .validate.DoubleRules double = 2 [json_name = "double"];
    case kDouble: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.type_.double__);
      break;
    }
    // .validate.Int32Rules int32 = 3 [json_name = "int32"];
    case kInt32: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.type_.int32_);
      break;
    }
    // .validate.Int64Rules int64 = 4 [json_name = "int64"];
    case kInt64: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.type_.int64_);
      break;
    }
    // .validate.UInt32Rules uint32 = 5 [json_name = "uint32"];
    case kUint32: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.type_.uint32_);
      break;
    }
    // .validate.UInt64Rules uint64 = 6 [json_name = "uint64"];
    case kUint64: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.type_.uint64_);
      break;
    }
    // .validate.SInt32Rules sint32 = 7 [json_name = "sint32"];
    case kSint32: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.type_.sint32_);
      break;
    }
    // .validate.SInt64Rules sint64 = 8 [json_name = "sint64"];
    case kSint64: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.type_.sint64_);
      break;
    }
    // .validate.Fixed32Rules fixed32 = 9 [json_name = "fixed32"];
    case kFixed32: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.type_.fixed32_);
      break;
    }
    // .validate.Fixed64Rules fixed64 = 10 [json_name = "fixed64"];
    case kFixed64: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.type_.fixed64_);
      break;
    }
    // .validate.SFixed32Rules sfixed32 = 11 [json_name = "sfixed32"];
    case kSfixed32: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.type_.sfixed32_);
      break;
    }
    // .validate.SFixed64Rules sfixed64 = 12 [json_name = "sfixed64"];
    case kSfixed64: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.type_.sfixed64_);
      break;
    }
    // .validate.BoolRules bool = 13 [json_name = "bool"];
    case kBool: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.type_.bool__);
      break;
    }
    // .validate.StringRules string = 14 [json_name = "string"];
    case kString: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.type_.string_);
      break;
    }
    // .validate.BytesRules bytes = 15 [json_name = "bytes"];
    case kBytes: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.type_.bytes_);
      break;
    }
    // .validate.EnumRules enum = 16 [json_name = "enum"];
    case kEnum: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.type_.enum__);
      break;
    }
    // .validate.RepeatedRules repeated = 18 [json_name = "repeated"];
    case kRepeated: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.type_.repeated_);
      break;
    }
    // .validate.MapRules map = 19 [json_name = "map"];
    case kMap: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.type_.map_);
      break;
    }
    // .validate.AnyRules any = 20 [json_name = "any"];
    case kAny: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.type_.any_);
      break;
    }
    // .validate.DurationRules duration = 21 [json_name = "duration"];
    case kDuration: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.type_.duration_);
      break;
    }
    // .validate.TimestampRules timestamp = 22 [json_name = "timestamp"];
    case kTimestamp: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.type_.timestamp_);
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FieldRules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FieldRules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FieldRules::GetClassData() const { return &_class_data_; }


void FieldRules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FieldRules*>(&to_msg);
  auto& from = static_cast<const FieldRules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:validate.FieldRules)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_message()) {
    _this->_internal_mutable_message()->::validate::MessageRules::MergeFrom(
        from._internal_message());
  }
  switch (from.type_case()) {
    case kFloat: {
      _this->_internal_mutable_float_()->::validate::FloatRules::MergeFrom(
          from._internal_float_());
      break;
    }
    case kDouble: {
      _this->_internal_mutable_double_()->::validate::DoubleRules::MergeFrom(
          from._internal_double_());
      break;
    }
    case kInt32: {
      _this->_internal_mutable_int32()->::validate::Int32Rules::MergeFrom(
          from._internal_int32());
      break;
    }
    case kInt64: {
      _this->_internal_mutable_int64()->::validate::Int64Rules::MergeFrom(
          from._internal_int64());
      break;
    }
    case kUint32: {
      _this->_internal_mutable_uint32()->::validate::UInt32Rules::MergeFrom(
          from._internal_uint32());
      break;
    }
    case kUint64: {
      _this->_internal_mutable_uint64()->::validate::UInt64Rules::MergeFrom(
          from._internal_uint64());
      break;
    }
    case kSint32: {
      _this->_internal_mutable_sint32()->::validate::SInt32Rules::MergeFrom(
          from._internal_sint32());
      break;
    }
    case kSint64: {
      _this->_internal_mutable_sint64()->::validate::SInt64Rules::MergeFrom(
          from._internal_sint64());
      break;
    }
    case kFixed32: {
      _this->_internal_mutable_fixed32()->::validate::Fixed32Rules::MergeFrom(
          from._internal_fixed32());
      break;
    }
    case kFixed64: {
      _this->_internal_mutable_fixed64()->::validate::Fixed64Rules::MergeFrom(
          from._internal_fixed64());
      break;
    }
    case kSfixed32: {
      _this->_internal_mutable_sfixed32()->::validate::SFixed32Rules::MergeFrom(
          from._internal_sfixed32());
      break;
    }
    case kSfixed64: {
      _this->_internal_mutable_sfixed64()->::validate::SFixed64Rules::MergeFrom(
          from._internal_sfixed64());
      break;
    }
    case kBool: {
      _this->_internal_mutable_bool_()->::validate::BoolRules::MergeFrom(
          from._internal_bool_());
      break;
    }
    case kString: {
      _this->_internal_mutable_string()->::validate::StringRules::MergeFrom(
          from._internal_string());
      break;
    }
    case kBytes: {
      _this->_internal_mutable_bytes()->::validate::BytesRules::MergeFrom(
          from._internal_bytes());
      break;
    }
    case kEnum: {
      _this->_internal_mutable_enum_()->::validate::EnumRules::MergeFrom(
          from._internal_enum_());
      break;
    }
    case kRepeated: {
      _this->_internal_mutable_repeated()->::validate::RepeatedRules::MergeFrom(
          from._internal_repeated());
      break;
    }
    case kMap: {
      _this->_internal_mutable_map()->::validate::MapRules::MergeFrom(
          from._internal_map());
      break;
    }
    case kAny: {
      _this->_internal_mutable_any()->::validate::AnyRules::MergeFrom(
          from._internal_any());
      break;
    }
    case kDuration: {
      _this->_internal_mutable_duration()->::validate::DurationRules::MergeFrom(
          from._internal_duration());
      break;
    }
    case kTimestamp: {
      _this->_internal_mutable_timestamp()->::validate::TimestampRules::MergeFrom(
          from._internal_timestamp());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FieldRules::CopyFrom(const FieldRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.FieldRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FieldRules::IsInitialized() const {
  return true;
}

void FieldRules::InternalSwap(FieldRules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.message_, other->_impl_.message_);
  swap(_impl_.type_, other->_impl_.type_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata FieldRules::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_validate_2fvalidate_2eproto_getter, &descriptor_table_validate_2fvalidate_2eproto_once,
      file_level_metadata_validate_2fvalidate_2eproto[0]);
}

// ===================================================================

class FloatRules::_Internal {
 public:
  using HasBits = decltype(std::declval<FloatRules>()._impl_._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_lt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lte(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gt(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_gte(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ignore_empty(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

FloatRules::FloatRules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:validate.FloatRules)
}
FloatRules::FloatRules(const FloatRules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FloatRules* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.in_){from._impl_.in_}
    , decltype(_impl_.not_in_){from._impl_.not_in_}
    , decltype(_impl_.const__){}
    , decltype(_impl_.lt_){}
    , decltype(_impl_.lte_){}
    , decltype(_impl_.gt_){}
    , decltype(_impl_.gte_){}
    , decltype(_impl_.ignore_empty_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.const__, &from._impl_.const__,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ignore_empty_) -
    reinterpret_cast<char*>(&_impl_.const__)) + sizeof(_impl_.ignore_empty_));
  // @@protoc_insertion_point(copy_constructor:validate.FloatRules)
}

inline void FloatRules::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.in_){arena}
    , decltype(_impl_.not_in_){arena}
    , decltype(_impl_.const__){0}
    , decltype(_impl_.lt_){0}
    , decltype(_impl_.lte_){0}
    , decltype(_impl_.gt_){0}
    , decltype(_impl_.gte_){0}
    , decltype(_impl_.ignore_empty_){false}
  };
}

FloatRules::~FloatRules() {
  // @@protoc_insertion_point(destructor:validate.FloatRules)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FloatRules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.in_.~RepeatedField();
  _impl_.not_in_.~RepeatedField();
}

void FloatRules::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FloatRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.FloatRules)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.const__, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ignore_empty_) -
        reinterpret_cast<char*>(&_impl_.const__)) + sizeof(_impl_.ignore_empty_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FloatRules::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float const = 1 [json_name = "const"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_const_(&has_bits);
          _impl_.const__ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float lt = 2 [json_name = "lt"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_lt(&has_bits);
          _impl_.lt_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float lte = 3 [json_name = "lte"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_lte(&has_bits);
          _impl_.lte_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float gt = 4 [json_name = "gt"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_gt(&has_bits);
          _impl_.gt_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float gte = 5 [json_name = "gte"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_gte(&has_bits);
          _impl_.gte_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated float in = 6 [json_name = "in"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_in(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
            ptr += sizeof(float);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<53>(ptr));
        } else if (static_cast<uint8_t>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_in(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated float not_in = 7 [json_name = "notIn"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_not_in(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
            ptr += sizeof(float);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<61>(ptr));
        } else if (static_cast<uint8_t>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_not_in(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool ignore_empty = 8 [json_name = "ignoreEmpty"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_ignore_empty(&has_bits);
          _impl_.ignore_empty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FloatRules::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.FloatRules)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional float const = 1 [json_name = "const"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_const_(), target);
  }

  // optional float lt = 2 [json_name = "lt"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_lt(), target);
  }

  // optional float lte = 3 [json_name = "lte"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_lte(), target);
  }

  // optional float gt = 4 [json_name = "gt"];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_gt(), target);
  }

  // optional float gte = 5 [json_name = "gte"];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_gte(), target);
  }

  // repeated float in = 6 [json_name = "in"];
  for (int i = 0, n = this->_internal_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_in(i), target);
  }

  // repeated float not_in = 7 [json_name = "notIn"];
  for (int i = 0, n = this->_internal_not_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_not_in(i), target);
  }

  // optional bool ignore_empty = 8 [json_name = "ignoreEmpty"];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_ignore_empty(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.FloatRules)
  return target;
}

size_t FloatRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.FloatRules)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float in = 6 [json_name = "in"];
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_in_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_in_size());
    total_size += data_size;
  }

  // repeated float not_in = 7 [json_name = "notIn"];
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_not_in_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_not_in_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional float const = 1 [json_name = "const"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float lt = 2 [json_name = "lt"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float lte = 3 [json_name = "lte"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float gt = 4 [json_name = "gt"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float gte = 5 [json_name = "gte"];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional bool ignore_empty = 8 [json_name = "ignoreEmpty"];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FloatRules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FloatRules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FloatRules::GetClassData() const { return &_class_data_; }


void FloatRules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FloatRules*>(&to_msg);
  auto& from = static_cast<const FloatRules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:validate.FloatRules)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.in_.MergeFrom(from._impl_.in_);
  _this->_impl_.not_in_.MergeFrom(from._impl_.not_in_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.const__ = from._impl_.const__;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.lt_ = from._impl_.lt_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.lte_ = from._impl_.lte_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.gt_ = from._impl_.gt_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.gte_ = from._impl_.gte_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.ignore_empty_ = from._impl_.ignore_empty_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FloatRules::CopyFrom(const FloatRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.FloatRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FloatRules::IsInitialized() const {
  return true;
}

void FloatRules::InternalSwap(FloatRules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.ignore_empty_)
      + sizeof(FloatRules::_impl_.ignore_empty_)
      - PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.const__)>(
          reinterpret_cast<char*>(&_impl_.const__),
          reinterpret_cast<char*>(&other->_impl_.const__));
}

::PROTOBUF_NAMESPACE_ID::Metadata FloatRules::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_validate_2fvalidate_2eproto_getter, &descriptor_table_validate_2fvalidate_2eproto_once,
      file_level_metadata_validate_2fvalidate_2eproto[1]);
}

// ===================================================================

class DoubleRules::_Internal {
 public:
  using HasBits = decltype(std::declval<DoubleRules>()._impl_._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_lt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lte(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gt(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_gte(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ignore_empty(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

DoubleRules::DoubleRules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:validate.DoubleRules)
}
DoubleRules::DoubleRules(const DoubleRules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DoubleRules* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.in_){from._impl_.in_}
    , decltype(_impl_.not_in_){from._impl_.not_in_}
    , decltype(_impl_.const__){}
    , decltype(_impl_.lt_){}
    , decltype(_impl_.lte_){}
    , decltype(_impl_.gt_){}
    , decltype(_impl_.gte_){}
    , decltype(_impl_.ignore_empty_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.const__, &from._impl_.const__,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ignore_empty_) -
    reinterpret_cast<char*>(&_impl_.const__)) + sizeof(_impl_.ignore_empty_));
  // @@protoc_insertion_point(copy_constructor:validate.DoubleRules)
}

inline void DoubleRules::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.in_){arena}
    , decltype(_impl_.not_in_){arena}
    , decltype(_impl_.const__){0}
    , decltype(_impl_.lt_){0}
    , decltype(_impl_.lte_){0}
    , decltype(_impl_.gt_){0}
    , decltype(_impl_.gte_){0}
    , decltype(_impl_.ignore_empty_){false}
  };
}

DoubleRules::~DoubleRules() {
  // @@protoc_insertion_point(destructor:validate.DoubleRules)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DoubleRules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.in_.~RepeatedField();
  _impl_.not_in_.~RepeatedField();
}

void DoubleRules::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DoubleRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.DoubleRules)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.const__, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ignore_empty_) -
        reinterpret_cast<char*>(&_impl_.const__)) + sizeof(_impl_.ignore_empty_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DoubleRules::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double const = 1 [json_name = "const"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_const_(&has_bits);
          _impl_.const__ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double lt = 2 [json_name = "lt"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_lt(&has_bits);
          _impl_.lt_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double lte = 3 [json_name = "lte"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_lte(&has_bits);
          _impl_.lte_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double gt = 4 [json_name = "gt"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_gt(&has_bits);
          _impl_.gt_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double gte = 5 [json_name = "gte"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_gte(&has_bits);
          _impl_.gte_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated double in = 6 [json_name = "in"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_in(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<49>(ptr));
        } else if (static_cast<uint8_t>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_in(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated double not_in = 7 [json_name = "notIn"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_not_in(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<57>(ptr));
        } else if (static_cast<uint8_t>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_not_in(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool ignore_empty = 8 [json_name = "ignoreEmpty"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_ignore_empty(&has_bits);
          _impl_.ignore_empty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DoubleRules::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.DoubleRules)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double const = 1 [json_name = "const"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_const_(), target);
  }

  // optional double lt = 2 [json_name = "lt"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_lt(), target);
  }

  // optional double lte = 3 [json_name = "lte"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_lte(), target);
  }

  // optional double gt = 4 [json_name = "gt"];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_gt(), target);
  }

  // optional double gte = 5 [json_name = "gte"];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_gte(), target);
  }

  // repeated double in = 6 [json_name = "in"];
  for (int i = 0, n = this->_internal_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_in(i), target);
  }

  // repeated double not_in = 7 [json_name = "notIn"];
  for (int i = 0, n = this->_internal_not_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(7, this->_internal_not_in(i), target);
  }

  // optional bool ignore_empty = 8 [json_name = "ignoreEmpty"];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_ignore_empty(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.DoubleRules)
  return target;
}

size_t DoubleRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.DoubleRules)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double in = 6 [json_name = "in"];
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_in_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_in_size());
    total_size += data_size;
  }

  // repeated double not_in = 7 [json_name = "notIn"];
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_not_in_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_not_in_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional double const = 1 [json_name = "const"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double lt = 2 [json_name = "lt"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double lte = 3 [json_name = "lte"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double gt = 4 [json_name = "gt"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional double gte = 5 [json_name = "gte"];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional bool ignore_empty = 8 [json_name = "ignoreEmpty"];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DoubleRules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DoubleRules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DoubleRules::GetClassData() const { return &_class_data_; }


void DoubleRules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DoubleRules*>(&to_msg);
  auto& from = static_cast<const DoubleRules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:validate.DoubleRules)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.in_.MergeFrom(from._impl_.in_);
  _this->_impl_.not_in_.MergeFrom(from._impl_.not_in_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.const__ = from._impl_.const__;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.lt_ = from._impl_.lt_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.lte_ = from._impl_.lte_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.gt_ = from._impl_.gt_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.gte_ = from._impl_.gte_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.ignore_empty_ = from._impl_.ignore_empty_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DoubleRules::CopyFrom(const DoubleRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.DoubleRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DoubleRules::IsInitialized() const {
  return true;
}

void DoubleRules::InternalSwap(DoubleRules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.ignore_empty_)
      + sizeof(DoubleRules::_impl_.ignore_empty_)
      - PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.const__)>(
          reinterpret_cast<char*>(&_impl_.const__),
          reinterpret_cast<char*>(&other->_impl_.const__));
}

::PROTOBUF_NAMESPACE_ID::Metadata DoubleRules::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_validate_2fvalidate_2eproto_getter, &descriptor_table_validate_2fvalidate_2eproto_once,
      file_level_metadata_validate_2fvalidate_2eproto[2]);
}

// ===================================================================

class Int32Rules::_Internal {
 public:
  using HasBits = decltype(std::declval<Int32Rules>()._impl_._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_lt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lte(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gt(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_gte(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ignore_empty(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

Int32Rules::Int32Rules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:validate.Int32Rules)
}
Int32Rules::Int32Rules(const Int32Rules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Int32Rules* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.in_){from._impl_.in_}
    , decltype(_impl_.not_in_){from._impl_.not_in_}
    , decltype(_impl_.const__){}
    , decltype(_impl_.lt_){}
    , decltype(_impl_.lte_){}
    , decltype(_impl_.gt_){}
    , decltype(_impl_.gte_){}
    , decltype(_impl_.ignore_empty_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.const__, &from._impl_.const__,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ignore_empty_) -
    reinterpret_cast<char*>(&_impl_.const__)) + sizeof(_impl_.ignore_empty_));
  // @@protoc_insertion_point(copy_constructor:validate.Int32Rules)
}

inline void Int32Rules::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.in_){arena}
    , decltype(_impl_.not_in_){arena}
    , decltype(_impl_.const__){0}
    , decltype(_impl_.lt_){0}
    , decltype(_impl_.lte_){0}
    , decltype(_impl_.gt_){0}
    , decltype(_impl_.gte_){0}
    , decltype(_impl_.ignore_empty_){false}
  };
}

Int32Rules::~Int32Rules() {
  // @@protoc_insertion_point(destructor:validate.Int32Rules)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Int32Rules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.in_.~RepeatedField();
  _impl_.not_in_.~RepeatedField();
}

void Int32Rules::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Int32Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.Int32Rules)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.const__, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ignore_empty_) -
        reinterpret_cast<char*>(&_impl_.const__)) + sizeof(_impl_.ignore_empty_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Int32Rules::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 const = 1 [json_name = "const"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_const_(&has_bits);
          _impl_.const__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 lt = 2 [json_name = "lt"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_lt(&has_bits);
          _impl_.lt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 lte = 3 [json_name = "lte"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_lte(&has_bits);
          _impl_.lte_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 gt = 4 [json_name = "gt"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_gt(&has_bits);
          _impl_.gt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 gte = 5 [json_name = "gte"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_gte(&has_bits);
          _impl_.gte_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 in = 6 [json_name = "in"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_in(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<48>(ptr));
        } else if (static_cast<uint8_t>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_in(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 not_in = 7 [json_name = "notIn"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_not_in(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<56>(ptr));
        } else if (static_cast<uint8_t>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_not_in(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool ignore_empty = 8 [json_name = "ignoreEmpty"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_ignore_empty(&has_bits);
          _impl_.ignore_empty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Int32Rules::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.Int32Rules)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 const = 1 [json_name = "const"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_const_(), target);
  }

  // optional int32 lt = 2 [json_name = "lt"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_lt(), target);
  }

  // optional int32 lte = 3 [json_name = "lte"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_lte(), target);
  }

  // optional int32 gt = 4 [json_name = "gt"];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_gt(), target);
  }

  // optional int32 gte = 5 [json_name = "gte"];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_gte(), target);
  }

  // repeated int32 in = 6 [json_name = "in"];
  for (int i = 0, n = this->_internal_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_in(i), target);
  }

  // repeated int32 not_in = 7 [json_name = "notIn"];
  for (int i = 0, n = this->_internal_not_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_not_in(i), target);
  }

  // optional bool ignore_empty = 8 [json_name = "ignoreEmpty"];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_ignore_empty(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.Int32Rules)
  return target;
}

size_t Int32Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.Int32Rules)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 in = 6 [json_name = "in"];
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.in_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_in_size());
    total_size += data_size;
  }

  // repeated int32 not_in = 7 [json_name = "notIn"];
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.not_in_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_not_in_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional int32 const = 1 [json_name = "const"];
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_const_());
    }

    // optional int32 lt = 2 [json_name = "lt"];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_lt());
    }

    // optional int32 lte = 3 [json_name = "lte"];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_lte());
    }

    // optional int32 gt = 4 [json_name = "gt"];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_gt());
    }

    // optional int32 gte = 5 [json_name = "gte"];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_gte());
    }

    // optional bool ignore_empty = 8 [json_name = "ignoreEmpty"];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Int32Rules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Int32Rules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Int32Rules::GetClassData() const { return &_class_data_; }


void Int32Rules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Int32Rules*>(&to_msg);
  auto& from = static_cast<const Int32Rules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:validate.Int32Rules)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.in_.MergeFrom(from._impl_.in_);
  _this->_impl_.not_in_.MergeFrom(from._impl_.not_in_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.const__ = from._impl_.const__;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.lt_ = from._impl_.lt_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.lte_ = from._impl_.lte_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.gt_ = from._impl_.gt_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.gte_ = from._impl_.gte_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.ignore_empty_ = from._impl_.ignore_empty_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Int32Rules::CopyFrom(const Int32Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.Int32Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Int32Rules::IsInitialized() const {
  return true;
}

void Int32Rules::InternalSwap(Int32Rules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_.ignore_empty_)
      + sizeof(Int32Rules::_impl_.ignore_empty_)
      - PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_.const__)>(
          reinterpret_cast<char*>(&_impl_.const__),
          reinterpret_cast<char*>(&other->_impl_.const__));
}

::PROTOBUF_NAMESPACE_ID::Metadata Int32Rules::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_validate_2fvalidate_2eproto_getter, &descriptor_table_validate_2fvalidate_2eproto_once,
      file_level_metadata_validate_2fvalidate_2eproto[3]);
}

// ===================================================================

class Int64Rules::_Internal {
 public:
  using HasBits = decltype(std::declval<Int64Rules>()._impl_._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_lt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lte(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gt(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_gte(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ignore_empty(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

Int64Rules::Int64Rules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:validate.Int64Rules)
}
Int64Rules::Int64Rules(const Int64Rules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Int64Rules* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.in_){from._impl_.in_}
    , decltype(_impl_.not_in_){from._impl_.not_in_}
    , decltype(_impl_.const__){}
    , decltype(_impl_.lt_){}
    , decltype(_impl_.lte_){}
    , decltype(_impl_.gt_){}
    , decltype(_impl_.gte_){}
    , decltype(_impl_.ignore_empty_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.const__, &from._impl_.const__,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ignore_empty_) -
    reinterpret_cast<char*>(&_impl_.const__)) + sizeof(_impl_.ignore_empty_));
  // @@protoc_insertion_point(copy_constructor:validate.Int64Rules)
}

inline void Int64Rules::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.in_){arena}
    , decltype(_impl_.not_in_){arena}
    , decltype(_impl_.const__){int64_t{0}}
    , decltype(_impl_.lt_){int64_t{0}}
    , decltype(_impl_.lte_){int64_t{0}}
    , decltype(_impl_.gt_){int64_t{0}}
    , decltype(_impl_.gte_){int64_t{0}}
    , decltype(_impl_.ignore_empty_){false}
  };
}

Int64Rules::~Int64Rules() {
  // @@protoc_insertion_point(destructor:validate.Int64Rules)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Int64Rules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.in_.~RepeatedField();
  _impl_.not_in_.~RepeatedField();
}

void Int64Rules::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Int64Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.Int64Rules)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.const__, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ignore_empty_) -
        reinterpret_cast<char*>(&_impl_.const__)) + sizeof(_impl_.ignore_empty_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Int64Rules::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 const = 1 [json_name = "const"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_const_(&has_bits);
          _impl_.const__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 lt = 2 [json_name = "lt"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_lt(&has_bits);
          _impl_.lt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 lte = 3 [json_name = "lte"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_lte(&has_bits);
          _impl_.lte_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 gt = 4 [json_name = "gt"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_gt(&has_bits);
          _impl_.gt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 gte = 5 [json_name = "gte"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_gte(&has_bits);
          _impl_.gte_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 in = 6 [json_name = "in"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_in(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<48>(ptr));
        } else if (static_cast<uint8_t>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_in(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 not_in = 7 [json_name = "notIn"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_not_in(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<56>(ptr));
        } else if (static_cast<uint8_t>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_not_in(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool ignore_empty = 8 [json_name = "ignoreEmpty"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_ignore_empty(&has_bits);
          _impl_.ignore_empty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Int64Rules::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.Int64Rules)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 const = 1 [json_name = "const"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_const_(), target);
  }

  // optional int64 lt = 2 [json_name = "lt"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_lt(), target);
  }

  // optional int64 lte = 3 [json_name = "lte"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_lte(), target);
  }

  // optional int64 gt = 4 [json_name = "gt"];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_gt(), target);
  }

  // optional int64 gte = 5 [json_name = "gte"];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_gte(), target);
  }

  // repeated int64 in = 6 [json_name = "in"];
  for (int i = 0, n = this->_internal_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_in(i), target);
  }

  // repeated int64 not_in = 7 [json_name = "notIn"];
  for (int i = 0, n = this->_internal_not_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(7, this->_internal_not_in(i), target);
  }

  // optional bool ignore_empty = 8 [json_name = "ignoreEmpty"];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_ignore_empty(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.Int64Rules)
  return target;
}

size_t Int64Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.Int64Rules)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 in = 6 [json_name = "in"];
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.in_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_in_size());
    total_size += data_size;
  }

  // repeated int64 not_in = 7 [json_name = "notIn"];
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.not_in_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_not_in_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional int64 const = 1 [json_name = "const"];
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_const_());
    }

    // optional int64 lt = 2 [json_name = "lt"];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_lt());
    }

    // optional int64 lte = 3 [json_name = "lte"];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_lte());
    }

    // optional int64 gt = 4 [json_name = "gt"];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_gt());
    }

    // optional int64 gte = 5 [json_name = "gte"];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_gte());
    }

    // optional bool ignore_empty = 8 [json_name = "ignoreEmpty"];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Int64Rules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Int64Rules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Int64Rules::GetClassData() const { return &_class_data_; }


void Int64Rules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Int64Rules*>(&to_msg);
  auto& from = static_cast<const Int64Rules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:validate.Int64Rules)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.in_.MergeFrom(from._impl_.in_);
  _this->_impl_.not_in_.MergeFrom(from._impl_.not_in_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.const__ = from._impl_.const__;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.lt_ = from._impl_.lt_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.lte_ = from._impl_.lte_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.gt_ = from._impl_.gt_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.gte_ = from._impl_.gte_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.ignore_empty_ = from._impl_.ignore_empty_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Int64Rules::CopyFrom(const Int64Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.Int64Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Int64Rules::IsInitialized() const {
  return true;
}

void Int64Rules::InternalSwap(Int64Rules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_.ignore_empty_)
      + sizeof(Int64Rules::_impl_.ignore_empty_)
      - PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_.const__)>(
          reinterpret_cast<char*>(&_impl_.const__),
          reinterpret_cast<char*>(&other->_impl_.const__));
}

::PROTOBUF_NAMESPACE_ID::Metadata Int64Rules::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_validate_2fvalidate_2eproto_getter, &descriptor_table_validate_2fvalidate_2eproto_once,
      file_level_metadata_validate_2fvalidate_2eproto[4]);
}

// ===================================================================

class UInt32Rules::_Internal {
 public:
  using HasBits = decltype(std::declval<UInt32Rules>()._impl_._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_lt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lte(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gt(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_gte(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ignore_empty(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

UInt32Rules::UInt32Rules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:validate.UInt32Rules)
}
UInt32Rules::UInt32Rules(const UInt32Rules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UInt32Rules* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.in_){from._impl_.in_}
    , decltype(_impl_.not_in_){from._impl_.not_in_}
    , decltype(_impl_.const__){}
    , decltype(_impl_.lt_){}
    , decltype(_impl_.lte_){}
    , decltype(_impl_.gt_){}
    , decltype(_impl_.gte_){}
    , decltype(_impl_.ignore_empty_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.const__, &from._impl_.const__,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ignore_empty_) -
    reinterpret_cast<char*>(&_impl_.const__)) + sizeof(_impl_.ignore_empty_));
  // @@protoc_insertion_point(copy_constructor:validate.UInt32Rules)
}

inline void UInt32Rules::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.in_){arena}
    , decltype(_impl_.not_in_){arena}
    , decltype(_impl_.const__){0u}
    , decltype(_impl_.lt_){0u}
    , decltype(_impl_.lte_){0u}
    , decltype(_impl_.gt_){0u}
    , decltype(_impl_.gte_){0u}
    , decltype(_impl_.ignore_empty_){false}
  };
}

UInt32Rules::~UInt32Rules() {
  // @@protoc_insertion_point(destructor:validate.UInt32Rules)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UInt32Rules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.in_.~RepeatedField();
  _impl_.not_in_.~RepeatedField();
}

void UInt32Rules::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UInt32Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.UInt32Rules)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.const__, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ignore_empty_) -
        reinterpret_cast<char*>(&_impl_.const__)) + sizeof(_impl_.ignore_empty_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UInt32Rules::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 const = 1 [json_name = "const"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_const_(&has_bits);
          _impl_.const__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 lt = 2 [json_name = "lt"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_lt(&has_bits);
          _impl_.lt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 lte = 3 [json_name = "lte"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_lte(&has_bits);
          _impl_.lte_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 gt = 4 [json_name = "gt"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_gt(&has_bits);
          _impl_.gt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 gte = 5 [json_name = "gte"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_gte(&has_bits);
          _impl_.gte_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 in = 6 [json_name = "in"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_in(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<48>(ptr));
        } else if (static_cast<uint8_t>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_in(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 not_in = 7 [json_name = "notIn"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_not_in(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<56>(ptr));
        } else if (static_cast<uint8_t>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_not_in(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool ignore_empty = 8 [json_name = "ignoreEmpty"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_ignore_empty(&has_bits);
          _impl_.ignore_empty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UInt32Rules::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.UInt32Rules)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 const = 1 [json_name = "const"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_const_(), target);
  }

  // optional uint32 lt = 2 [json_name = "lt"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_lt(), target);
  }

  // optional uint32 lte = 3 [json_name = "lte"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_lte(), target);
  }

  // optional uint32 gt = 4 [json_name = "gt"];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_gt(), target);
  }

  // optional uint32 gte = 5 [json_name = "gte"];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_gte(), target);
  }

  // repeated uint32 in = 6 [json_name = "in"];
  for (int i = 0, n = this->_internal_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_in(i), target);
  }

  // repeated uint32 not_in = 7 [json_name = "notIn"];
  for (int i = 0, n = this->_internal_not_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_not_in(i), target);
  }

  // optional bool ignore_empty = 8 [json_name = "ignoreEmpty"];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_ignore_empty(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.UInt32Rules)
  return target;
}

size_t UInt32Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.UInt32Rules)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 in = 6 [json_name = "in"];
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.in_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_in_size());
    total_size += data_size;
  }

  // repeated uint32 not_in = 7 [json_name = "notIn"];
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.not_in_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_not_in_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint32 const = 1 [json_name = "const"];
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_const_());
    }

    // optional uint32 lt = 2 [json_name = "lt"];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lt());
    }

    // optional uint32 lte = 3 [json_name = "lte"];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lte());
    }

    // optional uint32 gt = 4 [json_name = "gt"];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gt());
    }

    // optional uint32 gte = 5 [json_name = "gte"];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gte());
    }

    // optional bool ignore_empty = 8 [json_name = "ignoreEmpty"];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UInt32Rules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UInt32Rules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UInt32Rules::GetClassData() const { return &_class_data_; }


void UInt32Rules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UInt32Rules*>(&to_msg);
  auto& from = static_cast<const UInt32Rules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:validate.UInt32Rules)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.in_.MergeFrom(from._impl_.in_);
  _this->_impl_.not_in_.MergeFrom(from._impl_.not_in_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.const__ = from._impl_.const__;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.lt_ = from._impl_.lt_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.lte_ = from._impl_.lte_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.gt_ = from._impl_.gt_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.gte_ = from._impl_.gte_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.ignore_empty_ = from._impl_.ignore_empty_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UInt32Rules::CopyFrom(const UInt32Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.UInt32Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UInt32Rules::IsInitialized() const {
  return true;
}

void UInt32Rules::InternalSwap(UInt32Rules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_.ignore_empty_)
      + sizeof(UInt32Rules::_impl_.ignore_empty_)
      - PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_.const__)>(
          reinterpret_cast<char*>(&_impl_.const__),
          reinterpret_cast<char*>(&other->_impl_.const__));
}

::PROTOBUF_NAMESPACE_ID::Metadata UInt32Rules::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_validate_2fvalidate_2eproto_getter, &descriptor_table_validate_2fvalidate_2eproto_once,
      file_level_metadata_validate_2fvalidate_2eproto[5]);
}

// ===================================================================

class UInt64Rules::_Internal {
 public:
  using HasBits = decltype(std::declval<UInt64Rules>()._impl_._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_lt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lte(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gt(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_gte(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ignore_empty(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

UInt64Rules::UInt64Rules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:validate.UInt64Rules)
}
UInt64Rules::UInt64Rules(const UInt64Rules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UInt64Rules* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.in_){from._impl_.in_}
    , decltype(_impl_.not_in_){from._impl_.not_in_}
    , decltype(_impl_.const__){}
    , decltype(_impl_.lt_){}
    , decltype(_impl_.lte_){}
    , decltype(_impl_.gt_){}
    , decltype(_impl_.gte_){}
    , decltype(_impl_.ignore_empty_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.const__, &from._impl_.const__,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ignore_empty_) -
    reinterpret_cast<char*>(&_impl_.const__)) + sizeof(_impl_.ignore_empty_));
  // @@protoc_insertion_point(copy_constructor:validate.UInt64Rules)
}

inline void UInt64Rules::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.in_){arena}
    , decltype(_impl_.not_in_){arena}
    , decltype(_impl_.const__){uint64_t{0u}}
    , decltype(_impl_.lt_){uint64_t{0u}}
    , decltype(_impl_.lte_){uint64_t{0u}}
    , decltype(_impl_.gt_){uint64_t{0u}}
    , decltype(_impl_.gte_){uint64_t{0u}}
    , decltype(_impl_.ignore_empty_){false}
  };
}

UInt64Rules::~UInt64Rules() {
  // @@protoc_insertion_point(destructor:validate.UInt64Rules)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UInt64Rules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.in_.~RepeatedField();
  _impl_.not_in_.~RepeatedField();
}

void UInt64Rules::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UInt64Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.UInt64Rules)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.const__, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ignore_empty_) -
        reinterpret_cast<char*>(&_impl_.const__)) + sizeof(_impl_.ignore_empty_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UInt64Rules::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 const = 1 [json_name = "const"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_const_(&has_bits);
          _impl_.const__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 lt = 2 [json_name = "lt"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_lt(&has_bits);
          _impl_.lt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 lte = 3 [json_name = "lte"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_lte(&has_bits);
          _impl_.lte_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 gt = 4 [json_name = "gt"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_gt(&has_bits);
          _impl_.gt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 gte = 5 [json_name = "gte"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_gte(&has_bits);
          _impl_.gte_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 in = 6 [json_name = "in"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_in(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<48>(ptr));
        } else if (static_cast<uint8_t>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_in(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 not_in = 7 [json_name = "notIn"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_not_in(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<56>(ptr));
        } else if (static_cast<uint8_t>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_not_in(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool ignore_empty = 8 [json_name = "ignoreEmpty"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_ignore_empty(&has_bits);
          _impl_.ignore_empty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UInt64Rules::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.UInt64Rules)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 const = 1 [json_name = "const"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_const_(), target);
  }

  // optional uint64 lt = 2 [json_name = "lt"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_lt(), target);
  }

  // optional uint64 lte = 3 [json_name = "lte"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_lte(), target);
  }

  // optional uint64 gt = 4 [json_name = "gt"];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_gt(), target);
  }

  // optional uint64 gte = 5 [json_name = "gte"];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_gte(), target);
  }

  // repeated uint64 in = 6 [json_name = "in"];
  for (int i = 0, n = this->_internal_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal_in(i), target);
  }

  // repeated uint64 not_in = 7 [json_name = "notIn"];
  for (int i = 0, n = this->_internal_not_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(7, this->_internal_not_in(i), target);
  }

  // optional bool ignore_empty = 8 [json_name = "ignoreEmpty"];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_ignore_empty(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.UInt64Rules)
  return target;
}

size_t UInt64Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.UInt64Rules)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 in = 6 [json_name = "in"];
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_.in_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_in_size());
    total_size += data_size;
  }

  // repeated uint64 not_in = 7 [json_name = "notIn"];
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_.not_in_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_not_in_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint64 const = 1 [json_name = "const"];
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_const_());
    }

    // optional uint64 lt = 2 [json_name = "lt"];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_lt());
    }

    // optional uint64 lte = 3 [json_name = "lte"];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_lte());
    }

    // optional uint64 gt = 4 [json_name = "gt"];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_gt());
    }

    // optional uint64 gte = 5 [json_name = "gte"];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_gte());
    }

    // optional bool ignore_empty = 8 [json_name = "ignoreEmpty"];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UInt64Rules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UInt64Rules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UInt64Rules::GetClassData() const { return &_class_data_; }


void UInt64Rules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UInt64Rules*>(&to_msg);
  auto& from = static_cast<const UInt64Rules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:validate.UInt64Rules)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.in_.MergeFrom(from._impl_.in_);
  _this->_impl_.not_in_.MergeFrom(from._impl_.not_in_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.const__ = from._impl_.const__;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.lt_ = from._impl_.lt_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.lte_ = from._impl_.lte_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.gt_ = from._impl_.gt_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.gte_ = from._impl_.gte_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.ignore_empty_ = from._impl_.ignore_empty_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UInt64Rules::CopyFrom(const UInt64Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.UInt64Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UInt64Rules::IsInitialized() const {
  return true;
}

void UInt64Rules::InternalSwap(UInt64Rules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_.ignore_empty_)
      + sizeof(UInt64Rules::_impl_.ignore_empty_)
      - PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_.const__)>(
          reinterpret_cast<char*>(&_impl_.const__),
          reinterpret_cast<char*>(&other->_impl_.const__));
}

::PROTOBUF_NAMESPACE_ID::Metadata UInt64Rules::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_validate_2fvalidate_2eproto_getter, &descriptor_table_validate_2fvalidate_2eproto_once,
      file_level_metadata_validate_2fvalidate_2eproto[6]);
}

// ===================================================================

class SInt32Rules::_Internal {
 public:
  using HasBits = decltype(std::declval<SInt32Rules>()._impl_._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_lt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lte(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gt(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_gte(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ignore_empty(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

SInt32Rules::SInt32Rules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:validate.SInt32Rules)
}
SInt32Rules::SInt32Rules(const SInt32Rules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SInt32Rules* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.in_){from._impl_.in_}
    , decltype(_impl_.not_in_){from._impl_.not_in_}
    , decltype(_impl_.const__){}
    , decltype(_impl_.lt_){}
    , decltype(_impl_.lte_){}
    , decltype(_impl_.gt_){}
    , decltype(_impl_.gte_){}
    , decltype(_impl_.ignore_empty_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.const__, &from._impl_.const__,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ignore_empty_) -
    reinterpret_cast<char*>(&_impl_.const__)) + sizeof(_impl_.ignore_empty_));
  // @@protoc_insertion_point(copy_constructor:validate.SInt32Rules)
}

inline void SInt32Rules::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.in_){arena}
    , decltype(_impl_.not_in_){arena}
    , decltype(_impl_.const__){0}
    , decltype(_impl_.lt_){0}
    , decltype(_impl_.lte_){0}
    , decltype(_impl_.gt_){0}
    , decltype(_impl_.gte_){0}
    , decltype(_impl_.ignore_empty_){false}
  };
}

SInt32Rules::~SInt32Rules() {
  // @@protoc_insertion_point(destructor:validate.SInt32Rules)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SInt32Rules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.in_.~RepeatedField();
  _impl_.not_in_.~RepeatedField();
}

void SInt32Rules::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SInt32Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.SInt32Rules)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.const__, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ignore_empty_) -
        reinterpret_cast<char*>(&_impl_.const__)) + sizeof(_impl_.ignore_empty_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SInt32Rules::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional sint32 const = 1 [json_name = "const"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_const_(&has_bits);
          _impl_.const__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional sint32 lt = 2 [json_name = "lt"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_lt(&has_bits);
          _impl_.lt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional sint32 lte = 3 [json_name = "lte"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_lte(&has_bits);
          _impl_.lte_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional sint32 gt = 4 [json_name = "gt"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_gt(&has_bits);
          _impl_.gt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional sint32 gte = 5 [json_name = "gte"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_gte(&has_bits);
          _impl_.gte_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated sint32 in = 6 [json_name = "in"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_in(::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<48>(ptr));
        } else if (static_cast<uint8_t>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedSInt32Parser(_internal_mutable_in(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated sint32 not_in = 7 [json_name = "notIn"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_not_in(::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<56>(ptr));
        } else if (static_cast<uint8_t>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedSInt32Parser(_internal_mutable_not_in(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool ignore_empty = 8 [json_name = "ignoreEmpty"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_ignore_empty(&has_bits);
          _impl_.ignore_empty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SInt32Rules::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.SInt32Rules)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional sint32 const = 1 [json_name = "const"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(1, this->_internal_const_(), target);
  }

  // optional sint32 lt = 2 [json_name = "lt"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(2, this->_internal_lt(), target);
  }

  // optional sint32 lte = 3 [json_name = "lte"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(3, this->_internal_lte(), target);
  }

  // optional sint32 gt = 4 [json_name = "gt"];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(4, this->_internal_gt(), target);
  }

  // optional sint32 gte = 5 [json_name = "gte"];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(5, this->_internal_gte(), target);
  }

  // repeated sint32 in = 6 [json_name = "in"];
  for (int i = 0, n = this->_internal_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(6, this->_internal_in(i), target);
  }

  // repeated sint32 not_in = 7 [json_name = "notIn"];
  for (int i = 0, n = this->_internal_not_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(7, this->_internal_not_in(i), target);
  }

  // optional bool ignore_empty = 8 [json_name = "ignoreEmpty"];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_ignore_empty(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.SInt32Rules)
  return target;
}

size_t SInt32Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.SInt32Rules)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated sint32 in = 6 [json_name = "in"];
  {
    size_t data_size = ::_pbi::WireFormatLite::
      SInt32Size(this->_impl_.in_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_in_size());
    total_size += data_size;
  }

  // repeated sint32 not_in = 7 [json_name = "notIn"];
  {
    size_t data_size = ::_pbi::WireFormatLite::
      SInt32Size(this->_impl_.not_in_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_not_in_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional sint32 const = 1 [json_name = "const"];
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(this->_internal_const_());
    }

    // optional sint32 lt = 2 [json_name = "lt"];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(this->_internal_lt());
    }

    // optional sint32 lte = 3 [json_name = "lte"];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(this->_internal_lte());
    }

    // optional sint32 gt = 4 [json_name = "gt"];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(this->_internal_gt());
    }

    // optional sint32 gte = 5 [json_name = "gte"];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(this->_internal_gte());
    }

    // optional bool ignore_empty = 8 [json_name = "ignoreEmpty"];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SInt32Rules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SInt32Rules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SInt32Rules::GetClassData() const { return &_class_data_; }


void SInt32Rules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SInt32Rules*>(&to_msg);
  auto& from = static_cast<const SInt32Rules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:validate.SInt32Rules)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.in_.MergeFrom(from._impl_.in_);
  _this->_impl_.not_in_.MergeFrom(from._impl_.not_in_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.const__ = from._impl_.const__;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.lt_ = from._impl_.lt_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.lte_ = from._impl_.lte_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.gt_ = from._impl_.gt_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.gte_ = from._impl_.gte_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.ignore_empty_ = from._impl_.ignore_empty_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SInt32Rules::CopyFrom(const SInt32Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.SInt32Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SInt32Rules::IsInitialized() const {
  return true;
}

void SInt32Rules::InternalSwap(SInt32Rules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_.ignore_empty_)
      + sizeof(SInt32Rules::_impl_.ignore_empty_)
      - PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_.const__)>(
          reinterpret_cast<char*>(&_impl_.const__),
          reinterpret_cast<char*>(&other->_impl_.const__));
}

::PROTOBUF_NAMESPACE_ID::Metadata SInt32Rules::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_validate_2fvalidate_2eproto_getter, &descriptor_table_validate_2fvalidate_2eproto_once,
      file_level_metadata_validate_2fvalidate_2eproto[7]);
}

// ===================================================================

class SInt64Rules::_Internal {
 public:
  using HasBits = decltype(std::declval<SInt64Rules>()._impl_._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_lt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lte(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gt(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_gte(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ignore_empty(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

SInt64Rules::SInt64Rules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:validate.SInt64Rules)
}
SInt64Rules::SInt64Rules(const SInt64Rules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SInt64Rules* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.in_){from._impl_.in_}
    , decltype(_impl_.not_in_){from._impl_.not_in_}
    , decltype(_impl_.const__){}
    , decltype(_impl_.lt_){}
    , decltype(_impl_.lte_){}
    , decltype(_impl_.gt_){}
    , decltype(_impl_.gte_){}
    , decltype(_impl_.ignore_empty_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.const__, &from._impl_.const__,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ignore_empty_) -
    reinterpret_cast<char*>(&_impl_.const__)) + sizeof(_impl_.ignore_empty_));
  // @@protoc_insertion_point(copy_constructor:validate.SInt64Rules)
}

inline void SInt64Rules::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.in_){arena}
    , decltype(_impl_.not_in_){arena}
    , decltype(_impl_.const__){int64_t{0}}
    , decltype(_impl_.lt_){int64_t{0}}
    , decltype(_impl_.lte_){int64_t{0}}
    , decltype(_impl_.gt_){int64_t{0}}
    , decltype(_impl_.gte_){int64_t{0}}
    , decltype(_impl_.ignore_empty_){false}
  };
}

SInt64Rules::~SInt64Rules() {
  // @@protoc_insertion_point(destructor:validate.SInt64Rules)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SInt64Rules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.in_.~RepeatedField();
  _impl_.not_in_.~RepeatedField();
}

void SInt64Rules::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SInt64Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.SInt64Rules)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.const__, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ignore_empty_) -
        reinterpret_cast<char*>(&_impl_.const__)) + sizeof(_impl_.ignore_empty_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SInt64Rules::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional sint64 const = 1 [json_name = "const"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_const_(&has_bits);
          _impl_.const__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional sint64 lt = 2 [json_name = "lt"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_lt(&has_bits);
          _impl_.lt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional sint64 lte = 3 [json_name = "lte"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_lte(&has_bits);
          _impl_.lte_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional sint64 gt = 4 [json_name = "gt"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_gt(&has_bits);
          _impl_.gt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional sint64 gte = 5 [json_name = "gte"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_gte(&has_bits);
          _impl_.gte_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated sint64 in = 6 [json_name = "in"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_in(::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<48>(ptr));
        } else if (static_cast<uint8_t>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedSInt64Parser(_internal_mutable_in(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated sint64 not_in = 7 [json_name = "notIn"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_not_in(::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<56>(ptr));
        } else if (static_cast<uint8_t>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedSInt64Parser(_internal_mutable_not_in(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool ignore_empty = 8 [json_name = "ignoreEmpty"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_ignore_empty(&has_bits);
          _impl_.ignore_empty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SInt64Rules::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.SInt64Rules)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional sint64 const = 1 [json_name = "const"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(1, this->_internal_const_(), target);
  }

  // optional sint64 lt = 2 [json_name = "lt"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(2, this->_internal_lt(), target);
  }

  // optional sint64 lte = 3 [json_name = "lte"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(3, this->_internal_lte(), target);
  }

  // optional sint64 gt = 4 [json_name = "gt"];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(4, this->_internal_gt(), target);
  }

  // optional sint64 gte = 5 [json_name = "gte"];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(5, this->_internal_gte(), target);
  }

  // repeated sint64 in = 6 [json_name = "in"];
  for (int i = 0, n = this->_internal_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(6, this->_internal_in(i), target);
  }

  // repeated sint64 not_in = 7 [json_name = "notIn"];
  for (int i = 0, n = this->_internal_not_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(7, this->_internal_not_in(i), target);
  }

  // optional bool ignore_empty = 8 [json_name = "ignoreEmpty"];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_ignore_empty(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.SInt64Rules)
  return target;
}

size_t SInt64Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.SInt64Rules)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated sint64 in = 6 [json_name = "in"];
  {
    size_t data_size = ::_pbi::WireFormatLite::
      SInt64Size(this->_impl_.in_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_in_size());
    total_size += data_size;
  }

  // repeated sint64 not_in = 7 [json_name = "notIn"];
  {
    size_t data_size = ::_pbi::WireFormatLite::
      SInt64Size(this->_impl_.not_in_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_not_in_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional sint64 const = 1 [json_name = "const"];
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(this->_internal_const_());
    }

    // optional sint64 lt = 2 [json_name = "lt"];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(this->_internal_lt());
    }

    // optional sint64 lte = 3 [json_name = "lte"];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(this->_internal_lte());
    }

    // optional sint64 gt = 4 [json_name = "gt"];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(this->_internal_gt());
    }

    // optional sint64 gte = 5 [json_name = "gte"];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(this->_internal_gte());
    }

    // optional bool ignore_empty = 8 [json_name = "ignoreEmpty"];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SInt64Rules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SInt64Rules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SInt64Rules::GetClassData() const { return &_class_data_; }


void SInt64Rules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SInt64Rules*>(&to_msg);
  auto& from = static_cast<const SInt64Rules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:validate.SInt64Rules)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.in_.MergeFrom(from._impl_.in_);
  _this->_impl_.not_in_.MergeFrom(from._impl_.not_in_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.const__ = from._impl_.const__;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.lt_ = from._impl_.lt_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.lte_ = from._impl_.lte_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.gt_ = from._impl_.gt_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.gte_ = from._impl_.gte_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.ignore_empty_ = from._impl_.ignore_empty_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SInt64Rules::CopyFrom(const SInt64Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.SInt64Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SInt64Rules::IsInitialized() const {
  return true;
}

void SInt64Rules::InternalSwap(SInt64Rules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_.ignore_empty_)
      + sizeof(SInt64Rules::_impl_.ignore_empty_)
      - PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_.const__)>(
          reinterpret_cast<char*>(&_impl_.const__),
          reinterpret_cast<char*>(&other->_impl_.const__));
}

::PROTOBUF_NAMESPACE_ID::Metadata SInt64Rules::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_validate_2fvalidate_2eproto_getter, &descriptor_table_validate_2fvalidate_2eproto_once,
      file_level_metadata_validate_2fvalidate_2eproto[8]);
}

// ===================================================================

class Fixed32Rules::_Internal {
 public:
  using HasBits = decltype(std::declval<Fixed32Rules>()._impl_._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_lt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lte(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gt(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_gte(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ignore_empty(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

Fixed32Rules::Fixed32Rules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:validate.Fixed32Rules)
}
Fixed32Rules::Fixed32Rules(const Fixed32Rules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Fixed32Rules* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.in_){from._impl_.in_}
    , decltype(_impl_.not_in_){from._impl_.not_in_}
    , decltype(_impl_.const__){}
    , decltype(_impl_.lt_){}
    , decltype(_impl_.lte_){}
    , decltype(_impl_.gt_){}
    , decltype(_impl_.gte_){}
    , decltype(_impl_.ignore_empty_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.const__, &from._impl_.const__,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ignore_empty_) -
    reinterpret_cast<char*>(&_impl_.const__)) + sizeof(_impl_.ignore_empty_));
  // @@protoc_insertion_point(copy_constructor:validate.Fixed32Rules)
}

inline void Fixed32Rules::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.in_){arena}
    , decltype(_impl_.not_in_){arena}
    , decltype(_impl_.const__){0u}
    , decltype(_impl_.lt_){0u}
    , decltype(_impl_.lte_){0u}
    , decltype(_impl_.gt_){0u}
    , decltype(_impl_.gte_){0u}
    , decltype(_impl_.ignore_empty_){false}
  };
}

Fixed32Rules::~Fixed32Rules() {
  // @@protoc_insertion_point(destructor:validate.Fixed32Rules)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Fixed32Rules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.in_.~RepeatedField();
  _impl_.not_in_.~RepeatedField();
}

void Fixed32Rules::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Fixed32Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.Fixed32Rules)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.const__, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ignore_empty_) -
        reinterpret_cast<char*>(&_impl_.const__)) + sizeof(_impl_.ignore_empty_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Fixed32Rules::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed32 const = 1 [json_name = "const"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_const_(&has_bits);
          _impl_.const__ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 lt = 2 [json_name = "lt"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_lt(&has_bits);
          _impl_.lt_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 lte = 3 [json_name = "lte"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_lte(&has_bits);
          _impl_.lte_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 gt = 4 [json_name = "gt"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_gt(&has_bits);
          _impl_.gt_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 gte = 5 [json_name = "gte"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_gte(&has_bits);
          _impl_.gte_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // repeated fixed32 in = 6 [json_name = "in"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_in(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr));
            ptr += sizeof(uint32_t);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<53>(ptr));
        } else if (static_cast<uint8_t>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed32Parser(_internal_mutable_in(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated fixed32 not_in = 7 [json_name = "notIn"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_not_in(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr));
            ptr += sizeof(uint32_t);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<61>(ptr));
        } else if (static_cast<uint8_t>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed32Parser(_internal_mutable_not_in(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool ignore_empty = 8 [json_name = "ignoreEmpty"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_ignore_empty(&has_bits);
          _impl_.ignore_empty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Fixed32Rules::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.Fixed32Rules)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed32 const = 1 [json_name = "const"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(1, this->_internal_const_(), target);
  }

  // optional fixed32 lt = 2 [json_name = "lt"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(2, this->_internal_lt(), target);
  }

  // optional fixed32 lte = 3 [json_name = "lte"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(3, this->_internal_lte(), target);
  }

  // optional fixed32 gt = 4 [json_name = "gt"];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(4, this->_internal_gt(), target);
  }

  // optional fixed32 gte = 5 [json_name = "gte"];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(5, this->_internal_gte(), target);
  }

  // repeated fixed32 in = 6 [json_name = "in"];
  for (int i = 0, n = this->_internal_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(6, this->_internal_in(i), target);
  }

  // repeated fixed32 not_in = 7 [json_name = "notIn"];
  for (int i = 0, n = this->_internal_not_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(7, this->_internal_not_in(i), target);
  }

  // optional bool ignore_empty = 8 [json_name = "ignoreEmpty"];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_ignore_empty(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.Fixed32Rules)
  return target;
}

size_t Fixed32Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.Fixed32Rules)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated fixed32 in = 6 [json_name = "in"];
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_in_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_in_size());
    total_size += data_size;
  }

  // repeated fixed32 not_in = 7 [json_name = "notIn"];
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_not_in_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_not_in_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional fixed32 const = 1 [json_name = "const"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional fixed32 lt = 2 [json_name = "lt"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional fixed32 lte = 3 [json_name = "lte"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional fixed32 gt = 4 [json_name = "gt"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional fixed32 gte = 5 [json_name = "gte"];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional bool ignore_empty = 8 [json_name = "ignoreEmpty"];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Fixed32Rules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Fixed32Rules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Fixed32Rules::GetClassData() const { return &_class_data_; }


void Fixed32Rules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Fixed32Rules*>(&to_msg);
  auto& from = static_cast<const Fixed32Rules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:validate.Fixed32Rules)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.in_.MergeFrom(from._impl_.in_);
  _this->_impl_.not_in_.MergeFrom(from._impl_.not_in_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.const__ = from._impl_.const__;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.lt_ = from._impl_.lt_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.lte_ = from._impl_.lte_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.gt_ = from._impl_.gt_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.gte_ = from._impl_.gte_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.ignore_empty_ = from._impl_.ignore_empty_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Fixed32Rules::CopyFrom(const Fixed32Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.Fixed32Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Fixed32Rules::IsInitialized() const {
  return true;
}

void Fixed32Rules::InternalSwap(Fixed32Rules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_.ignore_empty_)
      + sizeof(Fixed32Rules::_impl_.ignore_empty_)
      - PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_.const__)>(
          reinterpret_cast<char*>(&_impl_.const__),
          reinterpret_cast<char*>(&other->_impl_.const__));
}

::PROTOBUF_NAMESPACE_ID::Metadata Fixed32Rules::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_validate_2fvalidate_2eproto_getter, &descriptor_table_validate_2fvalidate_2eproto_once,
      file_level_metadata_validate_2fvalidate_2eproto[9]);
}

// ===================================================================

class Fixed64Rules::_Internal {
 public:
  using HasBits = decltype(std::declval<Fixed64Rules>()._impl_._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_lt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lte(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gt(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_gte(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ignore_empty(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

Fixed64Rules::Fixed64Rules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:validate.Fixed64Rules)
}
Fixed64Rules::Fixed64Rules(const Fixed64Rules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Fixed64Rules* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.in_){from._impl_.in_}
    , decltype(_impl_.not_in_){from._impl_.not_in_}
    , decltype(_impl_.const__){}
    , decltype(_impl_.lt_){}
    , decltype(_impl_.lte_){}
    , decltype(_impl_.gt_){}
    , decltype(_impl_.gte_){}
    , decltype(_impl_.ignore_empty_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.const__, &from._impl_.const__,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ignore_empty_) -
    reinterpret_cast<char*>(&_impl_.const__)) + sizeof(_impl_.ignore_empty_));
  // @@protoc_insertion_point(copy_constructor:validate.Fixed64Rules)
}

inline void Fixed64Rules::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.in_){arena}
    , decltype(_impl_.not_in_){arena}
    , decltype(_impl_.const__){uint64_t{0u}}
    , decltype(_impl_.lt_){uint64_t{0u}}
    , decltype(_impl_.lte_){uint64_t{0u}}
    , decltype(_impl_.gt_){uint64_t{0u}}
    , decltype(_impl_.gte_){uint64_t{0u}}
    , decltype(_impl_.ignore_empty_){false}
  };
}

Fixed64Rules::~Fixed64Rules() {
  // @@protoc_insertion_point(destructor:validate.Fixed64Rules)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Fixed64Rules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.in_.~RepeatedField();
  _impl_.not_in_.~RepeatedField();
}

void Fixed64Rules::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Fixed64Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.Fixed64Rules)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.const__, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ignore_empty_) -
        reinterpret_cast<char*>(&_impl_.const__)) + sizeof(_impl_.ignore_empty_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Fixed64Rules::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 const = 1 [json_name = "const"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_const_(&has_bits);
          _impl_.const__ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 lt = 2 [json_name = "lt"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_lt(&has_bits);
          _impl_.lt_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 lte = 3 [json_name = "lte"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_lte(&has_bits);
          _impl_.lte_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 gt = 4 [json_name = "gt"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_gt(&has_bits);
          _impl_.gt_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 gte = 5 [json_name = "gte"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_gte(&has_bits);
          _impl_.gte_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // repeated fixed64 in = 6 [json_name = "in"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_in(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr));
            ptr += sizeof(uint64_t);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<49>(ptr));
        } else if (static_cast<uint8_t>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed64Parser(_internal_mutable_in(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated fixed64 not_in = 7 [json_name = "notIn"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_not_in(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr));
            ptr += sizeof(uint64_t);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<57>(ptr));
        } else if (static_cast<uint8_t>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed64Parser(_internal_mutable_not_in(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool ignore_empty = 8 [json_name = "ignoreEmpty"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_ignore_empty(&has_bits);
          _impl_.ignore_empty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Fixed64Rules::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.Fixed64Rules)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 const = 1 [json_name = "const"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_const_(), target);
  }

  // optional fixed64 lt = 2 [json_name = "lt"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(2, this->_internal_lt(), target);
  }

  // optional fixed64 lte = 3 [json_name = "lte"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(3, this->_internal_lte(), target);
  }

  // optional fixed64 gt = 4 [json_name = "gt"];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(4, this->_internal_gt(), target);
  }

  // optional fixed64 gte = 5 [json_name = "gte"];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(5, this->_internal_gte(), target);
  }

  // repeated fixed64 in = 6 [json_name = "in"];
  for (int i = 0, n = this->_internal_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(6, this->_internal_in(i), target);
  }

  // repeated fixed64 not_in = 7 [json_name = "notIn"];
  for (int i = 0, n = this->_internal_not_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(7, this->_internal_not_in(i), target);
  }

  // optional bool ignore_empty = 8 [json_name = "ignoreEmpty"];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_ignore_empty(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.Fixed64Rules)
  return target;
}

size_t Fixed64Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.Fixed64Rules)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated fixed64 in = 6 [json_name = "in"];
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_in_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_in_size());
    total_size += data_size;
  }

  // repeated fixed64 not_in = 7 [json_name = "notIn"];
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_not_in_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_not_in_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional fixed64 const = 1 [json_name = "const"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional fixed64 lt = 2 [json_name = "lt"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional fixed64 lte = 3 [json_name = "lte"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional fixed64 gt = 4 [json_name = "gt"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional fixed64 gte = 5 [json_name = "gte"];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional bool ignore_empty = 8 [json_name = "ignoreEmpty"];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Fixed64Rules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Fixed64Rules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Fixed64Rules::GetClassData() const { return &_class_data_; }


void Fixed64Rules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Fixed64Rules*>(&to_msg);
  auto& from = static_cast<const Fixed64Rules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:validate.Fixed64Rules)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.in_.MergeFrom(from._impl_.in_);
  _this->_impl_.not_in_.MergeFrom(from._impl_.not_in_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.const__ = from._impl_.const__;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.lt_ = from._impl_.lt_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.lte_ = from._impl_.lte_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.gt_ = from._impl_.gt_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.gte_ = from._impl_.gte_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.ignore_empty_ = from._impl_.ignore_empty_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Fixed64Rules::CopyFrom(const Fixed64Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.Fixed64Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Fixed64Rules::IsInitialized() const {
  return true;
}

void Fixed64Rules::InternalSwap(Fixed64Rules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_.ignore_empty_)
      + sizeof(Fixed64Rules::_impl_.ignore_empty_)
      - PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_.const__)>(
          reinterpret_cast<char*>(&_impl_.const__),
          reinterpret_cast<char*>(&other->_impl_.const__));
}

::PROTOBUF_NAMESPACE_ID::Metadata Fixed64Rules::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_validate_2fvalidate_2eproto_getter, &descriptor_table_validate_2fvalidate_2eproto_once,
      file_level_metadata_validate_2fvalidate_2eproto[10]);
}

// ===================================================================

class SFixed32Rules::_Internal {
 public:
  using HasBits = decltype(std::declval<SFixed32Rules>()._impl_._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_lt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lte(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gt(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_gte(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ignore_empty(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

SFixed32Rules::SFixed32Rules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:validate.SFixed32Rules)
}
SFixed32Rules::SFixed32Rules(const SFixed32Rules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SFixed32Rules* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.in_){from._impl_.in_}
    , decltype(_impl_.not_in_){from._impl_.not_in_}
    , decltype(_impl_.const__){}
    , decltype(_impl_.lt_){}
    , decltype(_impl_.lte_){}
    , decltype(_impl_.gt_){}
    , decltype(_impl_.gte_){}
    , decltype(_impl_.ignore_empty_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.const__, &from._impl_.const__,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ignore_empty_) -
    reinterpret_cast<char*>(&_impl_.const__)) + sizeof(_impl_.ignore_empty_));
  // @@protoc_insertion_point(copy_constructor:validate.SFixed32Rules)
}

inline void SFixed32Rules::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.in_){arena}
    , decltype(_impl_.not_in_){arena}
    , decltype(_impl_.const__){0}
    , decltype(_impl_.lt_){0}
    , decltype(_impl_.lte_){0}
    , decltype(_impl_.gt_){0}
    , decltype(_impl_.gte_){0}
    , decltype(_impl_.ignore_empty_){false}
  };
}

SFixed32Rules::~SFixed32Rules() {
  // @@protoc_insertion_point(destructor:validate.SFixed32Rules)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SFixed32Rules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.in_.~RepeatedField();
  _impl_.not_in_.~RepeatedField();
}

void SFixed32Rules::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SFixed32Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.SFixed32Rules)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.const__, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ignore_empty_) -
        reinterpret_cast<char*>(&_impl_.const__)) + sizeof(_impl_.ignore_empty_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SFixed32Rules::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional sfixed32 const = 1 [json_name = "const"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_const_(&has_bits);
          _impl_.const__ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<int32_t>(ptr);
          ptr += sizeof(int32_t);
        } else
          goto handle_unusual;
        continue;
      // optional sfixed32 lt = 2 [json_name = "lt"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_lt(&has_bits);
          _impl_.lt_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<int32_t>(ptr);
          ptr += sizeof(int32_t);
        } else
          goto handle_unusual;
        continue;
      // optional sfixed32 lte = 3 [json_name = "lte"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_lte(&has_bits);
          _impl_.lte_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<int32_t>(ptr);
          ptr += sizeof(int32_t);
        } else
          goto handle_unusual;
        continue;
      // optional sfixed32 gt = 4 [json_name = "gt"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_gt(&has_bits);
          _impl_.gt_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<int32_t>(ptr);
          ptr += sizeof(int32_t);
        } else
          goto handle_unusual;
        continue;
      // optional sfixed32 gte = 5 [json_name = "gte"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_gte(&has_bits);
          _impl_.gte_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<int32_t>(ptr);
          ptr += sizeof(int32_t);
        } else
          goto handle_unusual;
        continue;
      // repeated sfixed32 in = 6 [json_name = "in"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_in(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<int32_t>(ptr));
            ptr += sizeof(int32_t);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<53>(ptr));
        } else if (static_cast<uint8_t>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedSFixed32Parser(_internal_mutable_in(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated sfixed32 not_in = 7 [json_name = "notIn"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_not_in(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<int32_t>(ptr));
            ptr += sizeof(int32_t);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<61>(ptr));
        } else if (static_cast<uint8_t>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedSFixed32Parser(_internal_mutable_not_in(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool ignore_empty = 8 [json_name = "ignoreEmpty"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_ignore_empty(&has_bits);
          _impl_.ignore_empty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SFixed32Rules::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.SFixed32Rules)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional sfixed32 const = 1 [json_name = "const"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSFixed32ToArray(1, this->_internal_const_(), target);
  }

  // optional sfixed32 lt = 2 [json_name = "lt"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSFixed32ToArray(2, this->_internal_lt(), target);
  }

  // optional sfixed32 lte = 3 [json_name = "lte"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSFixed32ToArray(3, this->_internal_lte(), target);
  }

  // optional sfixed32 gt = 4 [json_name = "gt"];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSFixed32ToArray(4, this->_internal_gt(), target);
  }

  // optional sfixed32 gte = 5 [json_name = "gte"];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSFixed32ToArray(5, this->_internal_gte(), target);
  }

  // repeated sfixed32 in = 6 [json_name = "in"];
  for (int i = 0, n = this->_internal_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSFixed32ToArray(6, this->_internal_in(i), target);
  }

  // repeated sfixed32 not_in = 7 [json_name = "notIn"];
  for (int i = 0, n = this->_internal_not_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSFixed32ToArray(7, this->_internal_not_in(i), target);
  }

  // optional bool ignore_empty = 8 [json_name = "ignoreEmpty"];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_ignore_empty(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.SFixed32Rules)
  return target;
}

size_t SFixed32Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.SFixed32Rules)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated sfixed32 in = 6 [json_name = "in"];
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_in_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_in_size());
    total_size += data_size;
  }

  // repeated sfixed32 not_in = 7 [json_name = "notIn"];
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_not_in_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_not_in_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional sfixed32 const = 1 [json_name = "const"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional sfixed32 lt = 2 [json_name = "lt"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional sfixed32 lte = 3 [json_name = "lte"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional sfixed32 gt = 4 [json_name = "gt"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional sfixed32 gte = 5 [json_name = "gte"];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional bool ignore_empty = 8 [json_name = "ignoreEmpty"];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SFixed32Rules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SFixed32Rules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SFixed32Rules::GetClassData() const { return &_class_data_; }


void SFixed32Rules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SFixed32Rules*>(&to_msg);
  auto& from = static_cast<const SFixed32Rules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:validate.SFixed32Rules)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.in_.MergeFrom(from._impl_.in_);
  _this->_impl_.not_in_.MergeFrom(from._impl_.not_in_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.const__ = from._impl_.const__;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.lt_ = from._impl_.lt_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.lte_ = from._impl_.lte_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.gt_ = from._impl_.gt_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.gte_ = from._impl_.gte_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.ignore_empty_ = from._impl_.ignore_empty_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SFixed32Rules::CopyFrom(const SFixed32Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.SFixed32Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SFixed32Rules::IsInitialized() const {
  return true;
}

void SFixed32Rules::InternalSwap(SFixed32Rules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_.ignore_empty_)
      + sizeof(SFixed32Rules::_impl_.ignore_empty_)
      - PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_.const__)>(
          reinterpret_cast<char*>(&_impl_.const__),
          reinterpret_cast<char*>(&other->_impl_.const__));
}

::PROTOBUF_NAMESPACE_ID::Metadata SFixed32Rules::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_validate_2fvalidate_2eproto_getter, &descriptor_table_validate_2fvalidate_2eproto_once,
      file_level_metadata_validate_2fvalidate_2eproto[11]);
}

// ===================================================================

class SFixed64Rules::_Internal {
 public:
  using HasBits = decltype(std::declval<SFixed64Rules>()._impl_._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_lt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lte(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gt(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_gte(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ignore_empty(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

SFixed64Rules::SFixed64Rules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:validate.SFixed64Rules)
}
SFixed64Rules::SFixed64Rules(const SFixed64Rules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SFixed64Rules* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.in_){from._impl_.in_}
    , decltype(_impl_.not_in_){from._impl_.not_in_}
    , decltype(_impl_.const__){}
    , decltype(_impl_.lt_){}
    , decltype(_impl_.lte_){}
    , decltype(_impl_.gt_){}
    , decltype(_impl_.gte_){}
    , decltype(_impl_.ignore_empty_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.const__, &from._impl_.const__,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ignore_empty_) -
    reinterpret_cast<char*>(&_impl_.const__)) + sizeof(_impl_.ignore_empty_));
  // @@protoc_insertion_point(copy_constructor:validate.SFixed64Rules)
}

inline void SFixed64Rules::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.in_){arena}
    , decltype(_impl_.not_in_){arena}
    , decltype(_impl_.const__){int64_t{0}}
    , decltype(_impl_.lt_){int64_t{0}}
    , decltype(_impl_.lte_){int64_t{0}}
    , decltype(_impl_.gt_){int64_t{0}}
    , decltype(_impl_.gte_){int64_t{0}}
    , decltype(_impl_.ignore_empty_){false}
  };
}

SFixed64Rules::~SFixed64Rules() {
  // @@protoc_insertion_point(destructor:validate.SFixed64Rules)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SFixed64Rules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.in_.~RepeatedField();
  _impl_.not_in_.~RepeatedField();
}

void SFixed64Rules::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SFixed64Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.SFixed64Rules)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.const__, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ignore_empty_) -
        reinterpret_cast<char*>(&_impl_.const__)) + sizeof(_impl_.ignore_empty_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SFixed64Rules::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional sfixed64 const = 1 [json_name = "const"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_const_(&has_bits);
          _impl_.const__ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<int64_t>(ptr);
          ptr += sizeof(int64_t);
        } else
          goto handle_unusual;
        continue;
      // optional sfixed64 lt = 2 [json_name = "lt"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_lt(&has_bits);
          _impl_.lt_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<int64_t>(ptr);
          ptr += sizeof(int64_t);
        } else
          goto handle_unusual;
        continue;
      // optional sfixed64 lte = 3 [json_name = "lte"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_lte(&has_bits);
          _impl_.lte_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<int64_t>(ptr);
          ptr += sizeof(int64_t);
        } else
          goto handle_unusual;
        continue;
      // optional sfixed64 gt = 4 [json_name = "gt"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_gt(&has_bits);
          _impl_.gt_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<int64_t>(ptr);
          ptr += sizeof(int64_t);
        } else
          goto handle_unusual;
        continue;
      // optional sfixed64 gte = 5 [json_name = "gte"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_gte(&has_bits);
          _impl_.gte_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<int64_t>(ptr);
          ptr += sizeof(int64_t);
        } else
          goto handle_unusual;
        continue;
      // repeated sfixed64 in = 6 [json_name = "in"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_in(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<int64_t>(ptr));
            ptr += sizeof(int64_t);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<49>(ptr));
        } else if (static_cast<uint8_t>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedSFixed64Parser(_internal_mutable_in(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated sfixed64 not_in = 7 [json_name = "notIn"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_not_in(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<int64_t>(ptr));
            ptr += sizeof(int64_t);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<57>(ptr));
        } else if (static_cast<uint8_t>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedSFixed64Parser(_internal_mutable_not_in(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool ignore_empty = 8 [json_name = "ignoreEmpty"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_ignore_empty(&has_bits);
          _impl_.ignore_empty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SFixed64Rules::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.SFixed64Rules)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional sfixed64 const = 1 [json_name = "const"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSFixed64ToArray(1, this->_internal_const_(), target);
  }

  // optional sfixed64 lt = 2 [json_name = "lt"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSFixed64ToArray(2, this->_internal_lt(), target);
  }

  // optional sfixed64 lte = 3 [json_name = "lte"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSFixed64ToArray(3, this->_internal_lte(), target);
  }

  // optional sfixed64 gt = 4 [json_name = "gt"];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSFixed64ToArray(4, this->_internal_gt(), target);
  }

  // optional sfixed64 gte = 5 [json_name = "gte"];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSFixed64ToArray(5, this->_internal_gte(), target);
  }

  // repeated sfixed64 in = 6 [json_name = "in"];
  for (int i = 0, n = this->_internal_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSFixed64ToArray(6, this->_internal_in(i), target);
  }

  // repeated sfixed64 not_in = 7 [json_name = "notIn"];
  for (int i = 0, n = this->_internal_not_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSFixed64ToArray(7, this->_internal_not_in(i), target);
  }

  // optional bool ignore_empty = 8 [json_name = "ignoreEmpty"];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_ignore_empty(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.SFixed64Rules)
  return target;
}

size_t SFixed64Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.SFixed64Rules)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated sfixed64 in = 6 [json_name = "in"];
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_in_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_in_size());
    total_size += data_size;
  }

  // repeated sfixed64 not_in = 7 [json_name = "notIn"];
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_not_in_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_not_in_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional sfixed64 const = 1 [json_name = "const"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional sfixed64 lt = 2 [json_name = "lt"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional sfixed64 lte = 3 [json_name = "lte"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional sfixed64 gt = 4 [json_name = "gt"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional sfixed64 gte = 5 [json_name = "gte"];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional bool ignore_empty = 8 [json_name = "ignoreEmpty"];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SFixed64Rules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SFixed64Rules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SFixed64Rules::GetClassData() const { return &_class_data_; }


void SFixed64Rules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SFixed64Rules*>(&to_msg);
  auto& from = static_cast<const SFixed64Rules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:validate.SFixed64Rules)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.in_.MergeFrom(from._impl_.in_);
  _this->_impl_.not_in_.MergeFrom(from._impl_.not_in_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.const__ = from._impl_.const__;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.lt_ = from._impl_.lt_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.lte_ = from._impl_.lte_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.gt_ = from._impl_.gt_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.gte_ = from._impl_.gte_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.ignore_empty_ = from._impl_.ignore_empty_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SFixed64Rules::CopyFrom(const SFixed64Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.SFixed64Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SFixed64Rules::IsInitialized() const {
  return true;
}

void SFixed64Rules::InternalSwap(SFixed64Rules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_.ignore_empty_)
      + sizeof(SFixed64Rules::_impl_.ignore_empty_)
      - PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_.const__)>(
          reinterpret_cast<char*>(&_impl_.const__),
          reinterpret_cast<char*>(&other->_impl_.const__));
}

::PROTOBUF_NAMESPACE_ID::Metadata SFixed64Rules::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_validate_2fvalidate_2eproto_getter, &descriptor_table_validate_2fvalidate_2eproto_once,
      file_level_metadata_validate_2fvalidate_2eproto[12]);
}

// ===================================================================

class BoolRules::_Internal {
 public:
  using HasBits = decltype(std::declval<BoolRules>()._impl_._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

BoolRules::BoolRules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:validate.BoolRules)
}
BoolRules::BoolRules(const BoolRules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BoolRules* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.const__){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.const__ = from._impl_.const__;
  // @@protoc_insertion_point(copy_constructor:validate.BoolRules)
}

inline void BoolRules::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.const__){false}
  };
}

BoolRules::~BoolRules() {
  // @@protoc_insertion_point(destructor:validate.BoolRules)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BoolRules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BoolRules::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BoolRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.BoolRules)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.const__ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BoolRules::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool const = 1 [json_name = "const"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_const_(&has_bits);
          _impl_.const__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BoolRules::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.BoolRules)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool const = 1 [json_name = "const"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_const_(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.BoolRules)
  return target;
}

size_t BoolRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.BoolRules)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool const = 1 [json_name = "const"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BoolRules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BoolRules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BoolRules::GetClassData() const { return &_class_data_; }


void BoolRules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BoolRules*>(&to_msg);
  auto& from = static_cast<const BoolRules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:validate.BoolRules)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_const_()) {
    _this->_internal_set_const_(from._internal_const_());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BoolRules::CopyFrom(const BoolRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.BoolRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BoolRules::IsInitialized() const {
  return true;
}

void BoolRules::InternalSwap(BoolRules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.const__, other->_impl_.const__);
}

::PROTOBUF_NAMESPACE_ID::Metadata BoolRules::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_validate_2fvalidate_2eproto_getter, &descriptor_table_validate_2fvalidate_2eproto_once,
      file_level_metadata_validate_2fvalidate_2eproto[13]);
}

// ===================================================================

class StringRules::_Internal {
 public:
  using HasBits = decltype(std::declval<StringRules>()._impl_._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_min_len(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_max_len(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_len_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_min_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_max_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_pattern(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_prefix(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_suffix(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_contains(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_not_contains(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_strict(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_ignore_empty(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
};

StringRules::StringRules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:validate.StringRules)
}
StringRules::StringRules(const StringRules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StringRules* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.in_){from._impl_.in_}
    , decltype(_impl_.not_in_){from._impl_.not_in_}
    , decltype(_impl_.const__){}
    , decltype(_impl_.pattern_){}
    , decltype(_impl_.prefix_){}
    , decltype(_impl_.suffix_){}
    , decltype(_impl_.contains_){}
    , decltype(_impl_.not_contains_){}
    , decltype(_impl_.min_len_){}
    , decltype(_impl_.max_len_){}
    , decltype(_impl_.min_bytes_){}
    , decltype(_impl_.max_bytes_){}
    , decltype(_impl_.len_){}
    , decltype(_impl_.len_bytes_){}
    , decltype(_impl_.ignore_empty_){}
    , decltype(_impl_.strict_){}
    , decltype(_impl_.well_known_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.const__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.const__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_const_()) {
    _this->_impl_.const__.Set(from._internal_const_(), 
      _this->GetArenaForAllocation());
  }
  _impl_.pattern_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pattern_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_pattern()) {
    _this->_impl_.pattern_.Set(from._internal_pattern(), 
      _this->GetArenaForAllocation());
  }
  _impl_.prefix_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.prefix_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_prefix()) {
    _this->_impl_.prefix_.Set(from._internal_prefix(), 
      _this->GetArenaForAllocation());
  }
  _impl_.suffix_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.suffix_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_suffix()) {
    _this->_impl_.suffix_.Set(from._internal_suffix(), 
      _this->GetArenaForAllocation());
  }
  _impl_.contains_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contains_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_contains()) {
    _this->_impl_.contains_.Set(from._internal_contains(), 
      _this->GetArenaForAllocation());
  }
  _impl_.not_contains_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.not_contains_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_not_contains()) {
    _this->_impl_.not_contains_.Set(from._internal_not_contains(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.min_len_, &from._impl_.min_len_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.strict_) -
    reinterpret_cast<char*>(&_impl_.min_len_)) + sizeof(_impl_.strict_));
  clear_has_well_known();
  switch (from.well_known_case()) {
    case kEmail: {
      _this->_internal_set_email(from._internal_email());
      break;
    }
    case kHostname: {
      _this->_internal_set_hostname(from._internal_hostname());
      break;
    }
    case kIp: {
      _this->_internal_set_ip(from._internal_ip());
      break;
    }
    case kIpv4: {
      _this->_internal_set_ipv4(from._internal_ipv4());
      break;
    }
    case kIpv6: {
      _this->_internal_set_ipv6(from._internal_ipv6());
      break;
    }
    case kUri: {
      _this->_internal_set_uri(from._internal_uri());
      break;
    }
    case kUriRef: {
      _this->_internal_set_uri_ref(from._internal_uri_ref());
      break;
    }
    case kAddress: {
      _this->_internal_set_address(from._internal_address());
      break;
    }
    case kUuid: {
      _this->_internal_set_uuid(from._internal_uuid());
      break;
    }
    case kWellKnownRegex: {
      _this->_internal_set_well_known_regex(from._internal_well_known_regex());
      break;
    }
    case WELL_KNOWN_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:validate.StringRules)
}

inline void StringRules::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.in_){arena}
    , decltype(_impl_.not_in_){arena}
    , decltype(_impl_.const__){}
    , decltype(_impl_.pattern_){}
    , decltype(_impl_.prefix_){}
    , decltype(_impl_.suffix_){}
    , decltype(_impl_.contains_){}
    , decltype(_impl_.not_contains_){}
    , decltype(_impl_.min_len_){uint64_t{0u}}
    , decltype(_impl_.max_len_){uint64_t{0u}}
    , decltype(_impl_.min_bytes_){uint64_t{0u}}
    , decltype(_impl_.max_bytes_){uint64_t{0u}}
    , decltype(_impl_.len_){uint64_t{0u}}
    , decltype(_impl_.len_bytes_){uint64_t{0u}}
    , decltype(_impl_.ignore_empty_){false}
    , decltype(_impl_.strict_){true}
    , decltype(_impl_.well_known_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  _impl_.const__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.const__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.pattern_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pattern_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.prefix_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.prefix_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.suffix_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.suffix_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.contains_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contains_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.not_contains_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.not_contains_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clear_has_well_known();
}

StringRules::~StringRules() {
  // @@protoc_insertion_point(destructor:validate.StringRules)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StringRules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.in_.~RepeatedPtrField();
  _impl_.not_in_.~RepeatedPtrField();
  _impl_.const__.Destroy();
  _impl_.pattern_.Destroy();
  _impl_.prefix_.Destroy();
  _impl_.suffix_.Destroy();
  _impl_.contains_.Destroy();
  _impl_.not_contains_.Destroy();
  if (has_well_known()) {
    clear_well_known();
  }
}

void StringRules::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StringRules::clear_well_known() {
// @@protoc_insertion_point(one_of_clear_start:validate.StringRules)
  switch (well_known_case()) {
    case kEmail: {
      // No need to clear
      break;
    }
    case kHostname: {
      // No need to clear
      break;
    }
    case kIp: {
      // No need to clear
      break;
    }
    case kIpv4: {
      // No need to clear
      break;
    }
    case kIpv6: {
      // No need to clear
      break;
    }
    case kUri: {
      // No need to clear
      break;
    }
    case kUriRef: {
      // No need to clear
      break;
    }
    case kAddress: {
      // No need to clear
      break;
    }
    case kUuid: {
      // No need to clear
      break;
    }
    case kWellKnownRegex: {
      // No need to clear
      break;
    }
    case WELL_KNOWN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = WELL_KNOWN_NOT_SET;
}


void StringRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.StringRules)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.const__.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.pattern_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.prefix_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.suffix_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.contains_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.not_contains_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&_impl_.min_len_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.max_len_) -
        reinterpret_cast<char*>(&_impl_.min_len_)) + sizeof(_impl_.max_len_));
  }
  if (cached_has_bits & 0x00003f00u) {
    ::memset(&_impl_.min_bytes_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ignore_empty_) -
        reinterpret_cast<char*>(&_impl_.min_bytes_)) + sizeof(_impl_.ignore_empty_));
    _impl_.strict_ = true;
  }
  clear_well_known();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StringRules::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string const = 1 [json_name = "const"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_const_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "validate.StringRules.const");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint64 min_len = 2 [json_name = "minLen"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_min_len(&has_bits);
          _impl_.min_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 max_len = 3 [json_name = "maxLen"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_max_len(&has_bits);
          _impl_.max_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 min_bytes = 4 [json_name = "minBytes"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_min_bytes(&has_bits);
          _impl_.min_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 max_bytes = 5 [json_name = "maxBytes"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_max_bytes(&has_bits);
          _impl_.max_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string pattern = 6 [json_name = "pattern"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_pattern();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "validate.StringRules.pattern");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string prefix = 7 [json_name = "prefix"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_prefix();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "validate.StringRules.prefix");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string suffix = 8 [json_name = "suffix"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_suffix();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "validate.StringRules.suffix");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string contains = 9 [json_name = "contains"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_contains();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "validate.StringRules.contains");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated string in = 10 [json_name = "in"];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_in();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "validate.StringRules.in");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string not_in = 11 [json_name = "notIn"];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_not_in();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "validate.StringRules.not_in");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bool email = 12 [json_name = "email"];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _internal_set_email(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool hostname = 13 [json_name = "hostname"];
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _internal_set_hostname(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool ip = 14 [json_name = "ip"];
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _internal_set_ip(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool ipv4 = 15 [json_name = "ipv4"];
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _internal_set_ipv4(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool ipv6 = 16 [json_name = "ipv6"];
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _internal_set_ipv6(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool uri = 17 [json_name = "uri"];
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _internal_set_uri(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool uri_ref = 18 [json_name = "uriRef"];
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _internal_set_uri_ref(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 len = 19 [json_name = "len"];
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 len_bytes = 20 [json_name = "lenBytes"];
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_len_bytes(&has_bits);
          _impl_.len_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool address = 21 [json_name = "address"];
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _internal_set_address(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool uuid = 22 [json_name = "uuid"];
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _internal_set_uuid(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string not_contains = 23 [json_name = "notContains"];
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          auto str = _internal_mutable_not_contains();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "validate.StringRules.not_contains");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // .validate.KnownRegex well_known_regex = 24 [json_name = "wellKnownRegex"];
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::validate::KnownRegex_IsValid(val))) {
            _internal_set_well_known_regex(static_cast<::validate::KnownRegex>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(24, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool strict = 25 [default = true, json_name = "strict"];
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          _Internal::set_has_strict(&has_bits);
          _impl_.strict_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool ignore_empty = 26 [json_name = "ignoreEmpty"];
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          _Internal::set_has_ignore_empty(&has_bits);
          _impl_.ignore_empty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StringRules::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.StringRules)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string const = 1 [json_name = "const"];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_const_().data(), static_cast<int>(this->_internal_const_().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "validate.StringRules.const");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_const_(), target);
  }

  // optional uint64 min_len = 2 [json_name = "minLen"];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_min_len(), target);
  }

  // optional uint64 max_len = 3 [json_name = "maxLen"];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_max_len(), target);
  }

  // optional uint64 min_bytes = 4 [json_name = "minBytes"];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_min_bytes(), target);
  }

  // optional uint64 max_bytes = 5 [json_name = "maxBytes"];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_max_bytes(), target);
  }

  // optional string pattern = 6 [json_name = "pattern"];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_pattern().data(), static_cast<int>(this->_internal_pattern().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "validate.StringRules.pattern");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_pattern(), target);
  }

  // optional string prefix = 7 [json_name = "prefix"];
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_prefix().data(), static_cast<int>(this->_internal_prefix().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "validate.StringRules.prefix");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_prefix(), target);
  }

  // optional string suffix = 8 [json_name = "suffix"];
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_suffix().data(), static_cast<int>(this->_internal_suffix().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "validate.StringRules.suffix");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_suffix(), target);
  }

  // optional string contains = 9 [json_name = "contains"];
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_contains().data(), static_cast<int>(this->_internal_contains().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "validate.StringRules.contains");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_contains(), target);
  }

  // repeated string in = 10 [json_name = "in"];
  for (int i = 0, n = this->_internal_in_size(); i < n; i++) {
    const auto& s = this->_internal_in(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "validate.StringRules.in");
    target = stream->WriteString(10, s, target);
  }

  // repeated string not_in = 11 [json_name = "notIn"];
  for (int i = 0, n = this->_internal_not_in_size(); i < n; i++) {
    const auto& s = this->_internal_not_in(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "validate.StringRules.not_in");
    target = stream->WriteString(11, s, target);
  }

  switch (well_known_case()) {
    case kEmail: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_email(), target);
      break;
    }
    case kHostname: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_hostname(), target);
      break;
    }
    case kIp: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(14, this->_internal_ip(), target);
      break;
    }
    case kIpv4: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(15, this->_internal_ipv4(), target);
      break;
    }
    case kIpv6: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(16, this->_internal_ipv6(), target);
      break;
    }
    case kUri: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(17, this->_internal_uri(), target);
      break;
    }
    case kUriRef: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(18, this->_internal_uri_ref(), target);
      break;
    }
    default: ;
  }
  // optional uint64 len = 19 [json_name = "len"];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(19, this->_internal_len(), target);
  }

  // optional uint64 len_bytes = 20 [json_name = "lenBytes"];
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(20, this->_internal_len_bytes(), target);
  }

  switch (well_known_case()) {
    case kAddress: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(21, this->_internal_address(), target);
      break;
    }
    case kUuid: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(22, this->_internal_uuid(), target);
      break;
    }
    default: ;
  }
  // optional string not_contains = 23 [json_name = "notContains"];
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_not_contains().data(), static_cast<int>(this->_internal_not_contains().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "validate.StringRules.not_contains");
    target = stream->WriteStringMaybeAliased(
        23, this->_internal_not_contains(), target);
  }

  // .validate.KnownRegex well_known_regex = 24 [json_name = "wellKnownRegex"];
  if (_internal_has_well_known_regex()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      24, this->_internal_well_known_regex(), target);
  }

  // optional bool strict = 25 [default = true, json_name = "strict"];
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(25, this->_internal_strict(), target);
  }

  // optional bool ignore_empty = 26 [json_name = "ignoreEmpty"];
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(26, this->_internal_ignore_empty(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.StringRules)
  return target;
}

size_t StringRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.StringRules)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string in = 10 [json_name = "in"];
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.in_.size());
  for (int i = 0, n = _impl_.in_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.in_.Get(i));
  }

  // repeated string not_in = 11 [json_name = "notIn"];
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.not_in_.size());
  for (int i = 0, n = _impl_.not_in_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.not_in_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string const = 1 [json_name = "const"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_const_());
    }

    // optional string pattern = 6 [json_name = "pattern"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_pattern());
    }

    // optional string prefix = 7 [json_name = "prefix"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_prefix());
    }

    // optional string suffix = 8 [json_name = "suffix"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_suffix());
    }

    // optional string contains = 9 [json_name = "contains"];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_contains());
    }

    // optional string not_contains = 23 [json_name = "notContains"];
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_not_contains());
    }

    // optional uint64 min_len = 2 [json_name = "minLen"];
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_min_len());
    }

    // optional uint64 max_len = 3 [json_name = "maxLen"];
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_max_len());
    }

  }
  if (cached_has_bits & 0x00003f00u) {
    // optional uint64 min_bytes = 4 [json_name = "minBytes"];
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_min_bytes());
    }

    // optional uint64 max_bytes = 5 [json_name = "maxBytes"];
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_max_bytes());
    }

    // optional uint64 len = 19 [json_name = "len"];
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_len());
    }

    // optional uint64 len_bytes = 20 [json_name = "lenBytes"];
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_len_bytes());
    }

    // optional bool ignore_empty = 26 [json_name = "ignoreEmpty"];
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 + 1;
    }

    // optional bool strict = 25 [default = true, json_name = "strict"];
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 + 1;
    }

  }
  switch (well_known_case()) {
    // bool email = 12 [json_name = "email"];
    case kEmail: {
      total_size += 1 + 1;
      break;
    }
    // bool hostname = 13 [json_name = "hostname"];
    case kHostname: {
      total_size += 1 + 1;
      break;
    }
    // bool ip = 14 [json_name = "ip"];
    case kIp: {
      total_size += 1 + 1;
      break;
    }
    // bool ipv4 = 15 [json_name = "ipv4"];
    case kIpv4: {
      total_size += 1 + 1;
      break;
    }
    // bool ipv6 = 16 [json_name = "ipv6"];
    case kIpv6: {
      total_size += 2 + 1;
      break;
    }
    // bool uri = 17 [json_name = "uri"];
    case kUri: {
      total_size += 2 + 1;
      break;
    }
    // bool uri_ref = 18 [json_name = "uriRef"];
    case kUriRef: {
      total_size += 2 + 1;
      break;
    }
    // bool address = 21 [json_name = "address"];
    case kAddress: {
      total_size += 2 + 1;
      break;
    }
    // bool uuid = 22 [json_name = "uuid"];
    case kUuid: {
      total_size += 2 + 1;
      break;
    }
    // .validate.KnownRegex well_known_regex = 24 [json_name = "wellKnownRegex"];
    case kWellKnownRegex: {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_well_known_regex());
      break;
    }
    case WELL_KNOWN_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StringRules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StringRules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StringRules::GetClassData() const { return &_class_data_; }


void StringRules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StringRules*>(&to_msg);
  auto& from = static_cast<const StringRules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:validate.StringRules)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.in_.MergeFrom(from._impl_.in_);
  _this->_impl_.not_in_.MergeFrom(from._impl_.not_in_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_const_(from._internal_const_());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_pattern(from._internal_pattern());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_prefix(from._internal_prefix());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_suffix(from._internal_suffix());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_contains(from._internal_contains());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_not_contains(from._internal_not_contains());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.min_len_ = from._impl_.min_len_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.max_len_ = from._impl_.max_len_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.min_bytes_ = from._impl_.min_bytes_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.max_bytes_ = from._impl_.max_bytes_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.len_bytes_ = from._impl_.len_bytes_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.ignore_empty_ = from._impl_.ignore_empty_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.strict_ = from._impl_.strict_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  switch (from.well_known_case()) {
    case kEmail: {
      _this->_internal_set_email(from._internal_email());
      break;
    }
    case kHostname: {
      _this->_internal_set_hostname(from._internal_hostname());
      break;
    }
    case kIp: {
      _this->_internal_set_ip(from._internal_ip());
      break;
    }
    case kIpv4: {
      _this->_internal_set_ipv4(from._internal_ipv4());
      break;
    }
    case kIpv6: {
      _this->_internal_set_ipv6(from._internal_ipv6());
      break;
    }
    case kUri: {
      _this->_internal_set_uri(from._internal_uri());
      break;
    }
    case kUriRef: {
      _this->_internal_set_uri_ref(from._internal_uri_ref());
      break;
    }
    case kAddress: {
      _this->_internal_set_address(from._internal_address());
      break;
    }
    case kUuid: {
      _this->_internal_set_uuid(from._internal_uuid());
      break;
    }
    case kWellKnownRegex: {
      _this->_internal_set_well_known_regex(from._internal_well_known_regex());
      break;
    }
    case WELL_KNOWN_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StringRules::CopyFrom(const StringRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.StringRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StringRules::IsInitialized() const {
  return true;
}

void StringRules::InternalSwap(StringRules* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.const__, lhs_arena,
      &other->_impl_.const__, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.pattern_, lhs_arena,
      &other->_impl_.pattern_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.prefix_, lhs_arena,
      &other->_impl_.prefix_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.suffix_, lhs_arena,
      &other->_impl_.suffix_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.contains_, lhs_arena,
      &other->_impl_.contains_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.not_contains_, lhs_arena,
      &other->_impl_.not_contains_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StringRules, _impl_.ignore_empty_)
      + sizeof(StringRules::_impl_.ignore_empty_)
      - PROTOBUF_FIELD_OFFSET(StringRules, _impl_.min_len_)>(
          reinterpret_cast<char*>(&_impl_.min_len_),
          reinterpret_cast<char*>(&other->_impl_.min_len_));
  swap(_impl_.strict_, other->_impl_.strict_);
  swap(_impl_.well_known_, other->_impl_.well_known_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata StringRules::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_validate_2fvalidate_2eproto_getter, &descriptor_table_validate_2fvalidate_2eproto_once,
      file_level_metadata_validate_2fvalidate_2eproto[14]);
}

// ===================================================================

class BytesRules::_Internal {
 public:
  using HasBits = decltype(std::declval<BytesRules>()._impl_._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_min_len(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_max_len(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_pattern(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_prefix(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_suffix(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_contains(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ignore_empty(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

BytesRules::BytesRules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:validate.BytesRules)
}
BytesRules::BytesRules(const BytesRules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BytesRules* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.in_){from._impl_.in_}
    , decltype(_impl_.not_in_){from._impl_.not_in_}
    , decltype(_impl_.const__){}
    , decltype(_impl_.pattern_){}
    , decltype(_impl_.prefix_){}
    , decltype(_impl_.suffix_){}
    , decltype(_impl_.contains_){}
    , decltype(_impl_.min_len_){}
    , decltype(_impl_.max_len_){}
    , decltype(_impl_.len_){}
    , decltype(_impl_.ignore_empty_){}
    , decltype(_impl_.well_known_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.const__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.const__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_const_()) {
    _this->_impl_.const__.Set(from._internal_const_(), 
      _this->GetArenaForAllocation());
  }
  _impl_.pattern_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pattern_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_pattern()) {
    _this->_impl_.pattern_.Set(from._internal_pattern(), 
      _this->GetArenaForAllocation());
  }
  _impl_.prefix_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.prefix_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_prefix()) {
    _this->_impl_.prefix_.Set(from._internal_prefix(), 
      _this->GetArenaForAllocation());
  }
  _impl_.suffix_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.suffix_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_suffix()) {
    _this->_impl_.suffix_.Set(from._internal_suffix(), 
      _this->GetArenaForAllocation());
  }
  _impl_.contains_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contains_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_contains()) {
    _this->_impl_.contains_.Set(from._internal_contains(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.min_len_, &from._impl_.min_len_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ignore_empty_) -
    reinterpret_cast<char*>(&_impl_.min_len_)) + sizeof(_impl_.ignore_empty_));
  clear_has_well_known();
  switch (from.well_known_case()) {
    case kIp: {
      _this->_internal_set_ip(from._internal_ip());
      break;
    }
    case kIpv4: {
      _this->_internal_set_ipv4(from._internal_ipv4());
      break;
    }
    case kIpv6: {
      _this->_internal_set_ipv6(from._internal_ipv6());
      break;
    }
    case WELL_KNOWN_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:validate.BytesRules)
}

inline void BytesRules::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.in_){arena}
    , decltype(_impl_.not_in_){arena}
    , decltype(_impl_.const__){}
    , decltype(_impl_.pattern_){}
    , decltype(_impl_.prefix_){}
    , decltype(_impl_.suffix_){}
    , decltype(_impl_.contains_){}
    , decltype(_impl_.min_len_){uint64_t{0u}}
    , decltype(_impl_.max_len_){uint64_t{0u}}
    , decltype(_impl_.len_){uint64_t{0u}}
    , decltype(_impl_.ignore_empty_){false}
    , decltype(_impl_.well_known_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  _impl_.const__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.const__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.pattern_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pattern_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.prefix_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.prefix_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.suffix_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.suffix_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.contains_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contains_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clear_has_well_known();
}

BytesRules::~BytesRules() {
  // @@protoc_insertion_point(destructor:validate.BytesRules)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BytesRules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.in_.~RepeatedPtrField();
  _impl_.not_in_.~RepeatedPtrField();
  _impl_.const__.Destroy();
  _impl_.pattern_.Destroy();
  _impl_.prefix_.Destroy();
  _impl_.suffix_.Destroy();
  _impl_.contains_.Destroy();
  if (has_well_known()) {
    clear_well_known();
  }
}

void BytesRules::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BytesRules::clear_well_known() {
// @@protoc_insertion_point(one_of_clear_start:validate.BytesRules)
  switch (well_known_case()) {
    case kIp: {
      // No need to clear
      break;
    }
    case kIpv4: {
      // No need to clear
      break;
    }
    case kIpv6: {
      // No need to clear
      break;
    }
    case WELL_KNOWN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = WELL_KNOWN_NOT_SET;
}


void BytesRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.BytesRules)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.const__.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.pattern_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.prefix_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.suffix_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.contains_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&_impl_.min_len_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.len_) -
        reinterpret_cast<char*>(&_impl_.min_len_)) + sizeof(_impl_.len_));
  }
  _impl_.ignore_empty_ = false;
  clear_well_known();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BytesRules::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes const = 1 [json_name = "const"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_const_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 min_len = 2 [json_name = "minLen"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_min_len(&has_bits);
          _impl_.min_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 max_len = 3 [json_name = "maxLen"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_max_len(&has_bits);
          _impl_.max_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string pattern = 4 [json_name = "pattern"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_pattern();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "validate.BytesRules.pattern");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bytes prefix = 5 [json_name = "prefix"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_prefix();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes suffix = 6 [json_name = "suffix"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_suffix();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes contains = 7 [json_name = "contains"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_contains();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bytes in = 8 [json_name = "in"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_in();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated bytes not_in = 9 [json_name = "notIn"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_not_in();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bool ip = 10 [json_name = "ip"];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _internal_set_ip(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool ipv4 = 11 [json_name = "ipv4"];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _internal_set_ipv4(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool ipv6 = 12 [json_name = "ipv6"];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _internal_set_ipv6(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 len = 13 [json_name = "len"];
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool ignore_empty = 14 [json_name = "ignoreEmpty"];
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_ignore_empty(&has_bits);
          _impl_.ignore_empty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BytesRules::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.BytesRules)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes const = 1 [json_name = "const"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_const_(), target);
  }

  // optional uint64 min_len = 2 [json_name = "minLen"];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_min_len(), target);
  }

  // optional uint64 max_len = 3 [json_name = "maxLen"];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_max_len(), target);
  }

  // optional string pattern = 4 [json_name = "pattern"];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_pattern().data(), static_cast<int>(this->_internal_pattern().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "validate.BytesRules.pattern");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_pattern(), target);
  }

  // optional bytes prefix = 5 [json_name = "prefix"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_prefix(), target);
  }

  // optional bytes suffix = 6 [json_name = "suffix"];
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_suffix(), target);
  }

  // optional bytes contains = 7 [json_name = "contains"];
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_contains(), target);
  }

  // repeated bytes in = 8 [json_name = "in"];
  for (int i = 0, n = this->_internal_in_size(); i < n; i++) {
    const auto& s = this->_internal_in(i);
    target = stream->WriteBytes(8, s, target);
  }

  // repeated bytes not_in = 9 [json_name = "notIn"];
  for (int i = 0, n = this->_internal_not_in_size(); i < n; i++) {
    const auto& s = this->_internal_not_in(i);
    target = stream->WriteBytes(9, s, target);
  }

  switch (well_known_case()) {
    case kIp: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_ip(), target);
      break;
    }
    case kIpv4: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_ipv4(), target);
      break;
    }
    case kIpv6: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_ipv6(), target);
      break;
    }
    default: ;
  }
  // optional uint64 len = 13 [json_name = "len"];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(13, this->_internal_len(), target);
  }

  // optional bool ignore_empty = 14 [json_name = "ignoreEmpty"];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(14, this->_internal_ignore_empty(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.BytesRules)
  return target;
}

size_t BytesRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.BytesRules)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes in = 8 [json_name = "in"];
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.in_.size());
  for (int i = 0, n = _impl_.in_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      _impl_.in_.Get(i));
  }

  // repeated bytes not_in = 9 [json_name = "notIn"];
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.not_in_.size());
  for (int i = 0, n = _impl_.not_in_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      _impl_.not_in_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes const = 1 [json_name = "const"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_const_());
    }

    // optional string pattern = 4 [json_name = "pattern"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_pattern());
    }

    // optional bytes prefix = 5 [json_name = "prefix"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_prefix());
    }

    // optional bytes suffix = 6 [json_name = "suffix"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_suffix());
    }

    // optional bytes contains = 7 [json_name = "contains"];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_contains());
    }

    // optional uint64 min_len = 2 [json_name = "minLen"];
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_min_len());
    }

    // optional uint64 max_len = 3 [json_name = "maxLen"];
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_max_len());
    }

    // optional uint64 len = 13 [json_name = "len"];
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_len());
    }

  }
  // optional bool ignore_empty = 14 [json_name = "ignoreEmpty"];
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 + 1;
  }

  switch (well_known_case()) {
    // bool ip = 10 [json_name = "ip"];
    case kIp: {
      total_size += 1 + 1;
      break;
    }
    // bool ipv4 = 11 [json_name = "ipv4"];
    case kIpv4: {
      total_size += 1 + 1;
      break;
    }
    // bool ipv6 = 12 [json_name = "ipv6"];
    case kIpv6: {
      total_size += 1 + 1;
      break;
    }
    case WELL_KNOWN_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BytesRules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BytesRules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BytesRules::GetClassData() const { return &_class_data_; }


void BytesRules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BytesRules*>(&to_msg);
  auto& from = static_cast<const BytesRules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:validate.BytesRules)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.in_.MergeFrom(from._impl_.in_);
  _this->_impl_.not_in_.MergeFrom(from._impl_.not_in_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_const_(from._internal_const_());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_pattern(from._internal_pattern());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_prefix(from._internal_prefix());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_suffix(from._internal_suffix());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_contains(from._internal_contains());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.min_len_ = from._impl_.min_len_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.max_len_ = from._impl_.max_len_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_ignore_empty(from._internal_ignore_empty());
  }
  switch (from.well_known_case()) {
    case kIp: {
      _this->_internal_set_ip(from._internal_ip());
      break;
    }
    case kIpv4: {
      _this->_internal_set_ipv4(from._internal_ipv4());
      break;
    }
    case kIpv6: {
      _this->_internal_set_ipv6(from._internal_ipv6());
      break;
    }
    case WELL_KNOWN_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BytesRules::CopyFrom(const BytesRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.BytesRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BytesRules::IsInitialized() const {
  return true;
}

void BytesRules::InternalSwap(BytesRules* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.const__, lhs_arena,
      &other->_impl_.const__, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.pattern_, lhs_arena,
      &other->_impl_.pattern_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.prefix_, lhs_arena,
      &other->_impl_.prefix_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.suffix_, lhs_arena,
      &other->_impl_.suffix_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.contains_, lhs_arena,
      &other->_impl_.contains_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.ignore_empty_)
      + sizeof(BytesRules::_impl_.ignore_empty_)
      - PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.min_len_)>(
          reinterpret_cast<char*>(&_impl_.min_len_),
          reinterpret_cast<char*>(&other->_impl_.min_len_));
  swap(_impl_.well_known_, other->_impl_.well_known_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata BytesRules::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_validate_2fvalidate_2eproto_getter, &descriptor_table_validate_2fvalidate_2eproto_once,
      file_level_metadata_validate_2fvalidate_2eproto[15]);
}

// ===================================================================

class EnumRules::_Internal {
 public:
  using HasBits = decltype(std::declval<EnumRules>()._impl_._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_defined_only(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

EnumRules::EnumRules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:validate.EnumRules)
}
EnumRules::EnumRules(const EnumRules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EnumRules* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.in_){from._impl_.in_}
    , decltype(_impl_.not_in_){from._impl_.not_in_}
    , decltype(_impl_.const__){}
    , decltype(_impl_.defined_only_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.const__, &from._impl_.const__,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.defined_only_) -
    reinterpret_cast<char*>(&_impl_.const__)) + sizeof(_impl_.defined_only_));
  // @@protoc_insertion_point(copy_constructor:validate.EnumRules)
}

inline void EnumRules::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.in_){arena}
    , decltype(_impl_.not_in_){arena}
    , decltype(_impl_.const__){0}
    , decltype(_impl_.defined_only_){false}
  };
}

EnumRules::~EnumRules() {
  // @@protoc_insertion_point(destructor:validate.EnumRules)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EnumRules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.in_.~RepeatedField();
  _impl_.not_in_.~RepeatedField();
}

void EnumRules::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EnumRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.EnumRules)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.const__, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.defined_only_) -
        reinterpret_cast<char*>(&_impl_.const__)) + sizeof(_impl_.defined_only_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EnumRules::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 const = 1 [json_name = "const"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_const_(&has_bits);
          _impl_.const__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool defined_only = 2 [json_name = "definedOnly"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_defined_only(&has_bits);
          _impl_.defined_only_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 in = 3 [json_name = "in"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_in(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_in(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 not_in = 4 [json_name = "notIn"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_not_in(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_not_in(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EnumRules::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.EnumRules)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 const = 1 [json_name = "const"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_const_(), target);
  }

  // optional bool defined_only = 2 [json_name = "definedOnly"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_defined_only(), target);
  }

  // repeated int32 in = 3 [json_name = "in"];
  for (int i = 0, n = this->_internal_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_in(i), target);
  }

  // repeated int32 not_in = 4 [json_name = "notIn"];
  for (int i = 0, n = this->_internal_not_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_not_in(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.EnumRules)
  return target;
}

size_t EnumRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.EnumRules)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 in = 3 [json_name = "in"];
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.in_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_in_size());
    total_size += data_size;
  }

  // repeated int32 not_in = 4 [json_name = "notIn"];
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.not_in_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_not_in_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 const = 1 [json_name = "const"];
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_const_());
    }

    // optional bool defined_only = 2 [json_name = "definedOnly"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EnumRules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EnumRules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EnumRules::GetClassData() const { return &_class_data_; }


void EnumRules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EnumRules*>(&to_msg);
  auto& from = static_cast<const EnumRules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:validate.EnumRules)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.in_.MergeFrom(from._impl_.in_);
  _this->_impl_.not_in_.MergeFrom(from._impl_.not_in_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.const__ = from._impl_.const__;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.defined_only_ = from._impl_.defined_only_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EnumRules::CopyFrom(const EnumRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.EnumRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EnumRules::IsInitialized() const {
  return true;
}

void EnumRules::InternalSwap(EnumRules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EnumRules, _impl_.defined_only_)
      + sizeof(EnumRules::_impl_.defined_only_)
      - PROTOBUF_FIELD_OFFSET(EnumRules, _impl_.const__)>(
          reinterpret_cast<char*>(&_impl_.const__),
          reinterpret_cast<char*>(&other->_impl_.const__));
}

::PROTOBUF_NAMESPACE_ID::Metadata EnumRules::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_validate_2fvalidate_2eproto_getter, &descriptor_table_validate_2fvalidate_2eproto_once,
      file_level_metadata_validate_2fvalidate_2eproto[16]);
}

// ===================================================================

class MessageRules::_Internal {
 public:
  using HasBits = decltype(std::declval<MessageRules>()._impl_._has_bits_);
  static void set_has_skip(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_required(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

MessageRules::MessageRules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:validate.MessageRules)
}
MessageRules::MessageRules(const MessageRules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MessageRules* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.skip_){}
    , decltype(_impl_.required_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.skip_, &from._impl_.skip_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.required_) -
    reinterpret_cast<char*>(&_impl_.skip_)) + sizeof(_impl_.required_));
  // @@protoc_insertion_point(copy_constructor:validate.MessageRules)
}

inline void MessageRules::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.skip_){false}
    , decltype(_impl_.required_){false}
  };
}

MessageRules::~MessageRules() {
  // @@protoc_insertion_point(destructor:validate.MessageRules)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MessageRules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MessageRules::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MessageRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.MessageRules)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.skip_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.required_) -
      reinterpret_cast<char*>(&_impl_.skip_)) + sizeof(_impl_.required_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MessageRules::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool skip = 1 [json_name = "skip"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_skip(&has_bits);
          _impl_.skip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool required = 2 [json_name = "required"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_required(&has_bits);
          _impl_.required_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MessageRules::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.MessageRules)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool skip = 1 [json_name = "skip"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_skip(), target);
  }

  // optional bool required = 2 [json_name = "required"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_required(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.MessageRules)
  return target;
}

size_t MessageRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.MessageRules)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bool skip = 1 [json_name = "skip"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool required = 2 [json_name = "required"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MessageRules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MessageRules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MessageRules::GetClassData() const { return &_class_data_; }


void MessageRules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MessageRules*>(&to_msg);
  auto& from = static_cast<const MessageRules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:validate.MessageRules)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.skip_ = from._impl_.skip_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.required_ = from._impl_.required_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MessageRules::CopyFrom(const MessageRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.MessageRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MessageRules::IsInitialized() const {
  return true;
}

void MessageRules::InternalSwap(MessageRules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MessageRules, _impl_.required_)
      + sizeof(MessageRules::_impl_.required_)
      - PROTOBUF_FIELD_OFFSET(MessageRules, _impl_.skip_)>(
          reinterpret_cast<char*>(&_impl_.skip_),
          reinterpret_cast<char*>(&other->_impl_.skip_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MessageRules::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_validate_2fvalidate_2eproto_getter, &descriptor_table_validate_2fvalidate_2eproto_once,
      file_level_metadata_validate_2fvalidate_2eproto[17]);
}

// ===================================================================

class RepeatedRules::_Internal {
 public:
  using HasBits = decltype(std::declval<RepeatedRules>()._impl_._has_bits_);
  static void set_has_min_items(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_max_items(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_unique(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::validate::FieldRules& items(const RepeatedRules* msg);
  static void set_has_items(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ignore_empty(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::validate::FieldRules&
RepeatedRules::_Internal::items(const RepeatedRules* msg) {
  return *msg->_impl_.items_;
}
RepeatedRules::RepeatedRules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:validate.RepeatedRules)
}
RepeatedRules::RepeatedRules(const RepeatedRules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RepeatedRules* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){nullptr}
    , decltype(_impl_.min_items_){}
    , decltype(_impl_.max_items_){}
    , decltype(_impl_.unique_){}
    , decltype(_impl_.ignore_empty_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_items()) {
    _this->_impl_.items_ = new ::validate::FieldRules(*from._impl_.items_);
  }
  ::memcpy(&_impl_.min_items_, &from._impl_.min_items_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ignore_empty_) -
    reinterpret_cast<char*>(&_impl_.min_items_)) + sizeof(_impl_.ignore_empty_));
  // @@protoc_insertion_point(copy_constructor:validate.RepeatedRules)
}

inline void RepeatedRules::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){nullptr}
    , decltype(_impl_.min_items_){uint64_t{0u}}
    , decltype(_impl_.max_items_){uint64_t{0u}}
    , decltype(_impl_.unique_){false}
    , decltype(_impl_.ignore_empty_){false}
  };
}

RepeatedRules::~RepeatedRules() {
  // @@protoc_insertion_point(destructor:validate.RepeatedRules)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RepeatedRules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.items_;
}

void RepeatedRules::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RepeatedRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.RepeatedRules)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.items_ != nullptr);
    _impl_.items_->Clear();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.min_items_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ignore_empty_) -
        reinterpret_cast<char*>(&_impl_.min_items_)) + sizeof(_impl_.ignore_empty_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RepeatedRules::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 min_items = 1 [json_name = "minItems"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_min_items(&has_bits);
          _impl_.min_items_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 max_items = 2 [json_name = "maxItems"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_max_items(&has_bits);
          _impl_.max_items_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool unique = 3 [json_name = "unique"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_unique(&has_bits);
          _impl_.unique_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .validate.FieldRules items = 4 [json_name = "items"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_items(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool ignore_empty = 5 [json_name = "ignoreEmpty"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_ignore_empty(&has_bits);
          _impl_.ignore_empty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RepeatedRules::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.RepeatedRules)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 min_items = 1 [json_name = "minItems"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_min_items(), target);
  }

  // optional uint64 max_items = 2 [json_name = "maxItems"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_max_items(), target);
  }

  // optional bool unique = 3 [json_name = "unique"];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_unique(), target);
  }

  // optional .validate.FieldRules items = 4 [json_name = "items"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::items(this),
        _Internal::items(this).GetCachedSize(), target, stream);
  }

  // optional bool ignore_empty = 5 [json_name = "ignoreEmpty"];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_ignore_empty(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.RepeatedRules)
  return target;
}

size_t RepeatedRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.RepeatedRules)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .validate.FieldRules items = 4 [json_name = "items"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.items_);
    }

    // optional uint64 min_items = 1 [json_name = "minItems"];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_min_items());
    }

    // optional uint64 max_items = 2 [json_name = "maxItems"];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_max_items());
    }

    // optional bool unique = 3 [json_name = "unique"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool ignore_empty = 5 [json_name = "ignoreEmpty"];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RepeatedRules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RepeatedRules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RepeatedRules::GetClassData() const { return &_class_data_; }


void RepeatedRules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RepeatedRules*>(&to_msg);
  auto& from = static_cast<const RepeatedRules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:validate.RepeatedRules)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_items()->::validate::FieldRules::MergeFrom(
          from._internal_items());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.min_items_ = from._impl_.min_items_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.max_items_ = from._impl_.max_items_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.unique_ = from._impl_.unique_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.ignore_empty_ = from._impl_.ignore_empty_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RepeatedRules::CopyFrom(const RepeatedRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.RepeatedRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RepeatedRules::IsInitialized() const {
  return true;
}

void RepeatedRules::InternalSwap(RepeatedRules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RepeatedRules, _impl_.ignore_empty_)
      + sizeof(RepeatedRules::_impl_.ignore_empty_)
      - PROTOBUF_FIELD_OFFSET(RepeatedRules, _impl_.items_)>(
          reinterpret_cast<char*>(&_impl_.items_),
          reinterpret_cast<char*>(&other->_impl_.items_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RepeatedRules::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_validate_2fvalidate_2eproto_getter, &descriptor_table_validate_2fvalidate_2eproto_once,
      file_level_metadata_validate_2fvalidate_2eproto[18]);
}

// ===================================================================

class MapRules::_Internal {
 public:
  using HasBits = decltype(std::declval<MapRules>()._impl_._has_bits_);
  static void set_has_min_pairs(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_max_pairs(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_no_sparse(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::validate::FieldRules& keys(const MapRules* msg);
  static void set_has_keys(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::validate::FieldRules& values(const MapRules* msg);
  static void set_has_values(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ignore_empty(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::validate::FieldRules&
MapRules::_Internal::keys(const MapRules* msg) {
  return *msg->_impl_.keys_;
}
const ::validate::FieldRules&
MapRules::_Internal::values(const MapRules* msg) {
  return *msg->_impl_.values_;
}
MapRules::MapRules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:validate.MapRules)
}
MapRules::MapRules(const MapRules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MapRules* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.keys_){nullptr}
    , decltype(_impl_.values_){nullptr}
    , decltype(_impl_.min_pairs_){}
    , decltype(_impl_.max_pairs_){}
    , decltype(_impl_.no_sparse_){}
    , decltype(_impl_.ignore_empty_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_keys()) {
    _this->_impl_.keys_ = new ::validate::FieldRules(*from._impl_.keys_);
  }
  if (from._internal_has_values()) {
    _this->_impl_.values_ = new ::validate::FieldRules(*from._impl_.values_);
  }
  ::memcpy(&_impl_.min_pairs_, &from._impl_.min_pairs_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ignore_empty_) -
    reinterpret_cast<char*>(&_impl_.min_pairs_)) + sizeof(_impl_.ignore_empty_));
  // @@protoc_insertion_point(copy_constructor:validate.MapRules)
}

inline void MapRules::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.keys_){nullptr}
    , decltype(_impl_.values_){nullptr}
    , decltype(_impl_.min_pairs_){uint64_t{0u}}
    , decltype(_impl_.max_pairs_){uint64_t{0u}}
    , decltype(_impl_.no_sparse_){false}
    , decltype(_impl_.ignore_empty_){false}
  };
}

MapRules::~MapRules() {
  // @@protoc_insertion_point(destructor:validate.MapRules)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MapRules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.keys_;
  if (this != internal_default_instance()) delete _impl_.values_;
}

void MapRules::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MapRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.MapRules)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.keys_ != nullptr);
      _impl_.keys_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.values_ != nullptr);
      _impl_.values_->Clear();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&_impl_.min_pairs_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ignore_empty_) -
        reinterpret_cast<char*>(&_impl_.min_pairs_)) + sizeof(_impl_.ignore_empty_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MapRules::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 min_pairs = 1 [json_name = "minPairs"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_min_pairs(&has_bits);
          _impl_.min_pairs_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 max_pairs = 2 [json_name = "maxPairs"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_max_pairs(&has_bits);
          _impl_.max_pairs_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool no_sparse = 3 [json_name = "noSparse"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_no_sparse(&has_bits);
          _impl_.no_sparse_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .validate.FieldRules keys = 4 [json_name = "keys"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_keys(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .validate.FieldRules values = 5 [json_name = "values"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_values(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool ignore_empty = 6 [json_name = "ignoreEmpty"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_ignore_empty(&has_bits);
          _impl_.ignore_empty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MapRules::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.MapRules)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 min_pairs = 1 [json_name = "minPairs"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_min_pairs(), target);
  }

  // optional uint64 max_pairs = 2 [json_name = "maxPairs"];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_max_pairs(), target);
  }

  // optional bool no_sparse = 3 [json_name = "noSparse"];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_no_sparse(), target);
  }

  // optional .validate.FieldRules keys = 4 [json_name = "keys"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::keys(this),
        _Internal::keys(this).GetCachedSize(), target, stream);
  }

  // optional .validate.FieldRules values = 5 [json_name = "values"];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::values(this),
        _Internal::values(this).GetCachedSize(), target, stream);
  }

  // optional bool ignore_empty = 6 [json_name = "ignoreEmpty"];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_ignore_empty(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.MapRules)
  return target;
}

size_t MapRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.MapRules)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .validate.FieldRules keys = 4 [json_name = "keys"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.keys_);
    }

    // optional .validate.FieldRules values = 5 [json_name = "values"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.values_);
    }

    // optional uint64 min_pairs = 1 [json_name = "minPairs"];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_min_pairs());
    }

    // optional uint64 max_pairs = 2 [json_name = "maxPairs"];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_max_pairs());
    }

    // optional bool no_sparse = 3 [json_name = "noSparse"];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool ignore_empty = 6 [json_name = "ignoreEmpty"];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MapRules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MapRules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MapRules::GetClassData() const { return &_class_data_; }


void MapRules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MapRules*>(&to_msg);
  auto& from = static_cast<const MapRules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:validate.MapRules)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_keys()->::validate::FieldRules::MergeFrom(
          from._internal_keys());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_values()->::validate::FieldRules::MergeFrom(
          from._internal_values());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.min_pairs_ = from._impl_.min_pairs_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.max_pairs_ = from._impl_.max_pairs_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.no_sparse_ = from._impl_.no_sparse_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.ignore_empty_ = from._impl_.ignore_empty_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MapRules::CopyFrom(const MapRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.MapRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapRules::IsInitialized() const {
  return true;
}

void MapRules::InternalSwap(MapRules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MapRules, _impl_.ignore_empty_)
      + sizeof(MapRules::_impl_.ignore_empty_)
      - PROTOBUF_FIELD_OFFSET(MapRules, _impl_.keys_)>(
          reinterpret_cast<char*>(&_impl_.keys_),
          reinterpret_cast<char*>(&other->_impl_.keys_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MapRules::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_validate_2fvalidate_2eproto_getter, &descriptor_table_validate_2fvalidate_2eproto_once,
      file_level_metadata_validate_2fvalidate_2eproto[19]);
}

// ===================================================================

class AnyRules::_Internal {
 public:
  using HasBits = decltype(std::declval<AnyRules>()._impl_._has_bits_);
  static void set_has_required(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

AnyRules::AnyRules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:validate.AnyRules)
}
AnyRules::AnyRules(const AnyRules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AnyRules* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.in_){from._impl_.in_}
    , decltype(_impl_.not_in_){from._impl_.not_in_}
    , decltype(_impl_.required_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.required_ = from._impl_.required_;
  // @@protoc_insertion_point(copy_constructor:validate.AnyRules)
}

inline void AnyRules::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.in_){arena}
    , decltype(_impl_.not_in_){arena}
    , decltype(_impl_.required_){false}
  };
}

AnyRules::~AnyRules() {
  // @@protoc_insertion_point(destructor:validate.AnyRules)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AnyRules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.in_.~RepeatedPtrField();
  _impl_.not_in_.~RepeatedPtrField();
}

void AnyRules::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AnyRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.AnyRules)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  _impl_.required_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AnyRules::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool required = 1 [json_name = "required"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_required(&has_bits);
          _impl_.required_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string in = 2 [json_name = "in"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_in();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "validate.AnyRules.in");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string not_in = 3 [json_name = "notIn"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_not_in();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "validate.AnyRules.not_in");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AnyRules::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.AnyRules)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool required = 1 [json_name = "required"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_required(), target);
  }

  // repeated string in = 2 [json_name = "in"];
  for (int i = 0, n = this->_internal_in_size(); i < n; i++) {
    const auto& s = this->_internal_in(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "validate.AnyRules.in");
    target = stream->WriteString(2, s, target);
  }

  // repeated string not_in = 3 [json_name = "notIn"];
  for (int i = 0, n = this->_internal_not_in_size(); i < n; i++) {
    const auto& s = this->_internal_not_in(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "validate.AnyRules.not_in");
    target = stream->WriteString(3, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.AnyRules)
  return target;
}

size_t AnyRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.AnyRules)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string in = 2 [json_name = "in"];
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.in_.size());
  for (int i = 0, n = _impl_.in_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.in_.Get(i));
  }

  // repeated string not_in = 3 [json_name = "notIn"];
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.not_in_.size());
  for (int i = 0, n = _impl_.not_in_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.not_in_.Get(i));
  }

  // optional bool required = 1 [json_name = "required"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AnyRules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AnyRules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AnyRules::GetClassData() const { return &_class_data_; }


void AnyRules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AnyRules*>(&to_msg);
  auto& from = static_cast<const AnyRules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:validate.AnyRules)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.in_.MergeFrom(from._impl_.in_);
  _this->_impl_.not_in_.MergeFrom(from._impl_.not_in_);
  if (from._internal_has_required()) {
    _this->_internal_set_required(from._internal_required());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AnyRules::CopyFrom(const AnyRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.AnyRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AnyRules::IsInitialized() const {
  return true;
}

void AnyRules::InternalSwap(AnyRules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  swap(_impl_.required_, other->_impl_.required_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AnyRules::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_validate_2fvalidate_2eproto_getter, &descriptor_table_validate_2fvalidate_2eproto_once,
      file_level_metadata_validate_2fvalidate_2eproto[20]);
}

// ===================================================================

class DurationRules::_Internal {
 public:
  using HasBits = decltype(std::declval<DurationRules>()._impl_._has_bits_);
  static void set_has_required(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Duration& const_(const DurationRules* msg);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Duration& lt(const DurationRules* msg);
  static void set_has_lt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Duration& lte(const DurationRules* msg);
  static void set_has_lte(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Duration& gt(const DurationRules* msg);
  static void set_has_gt(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Duration& gte(const DurationRules* msg);
  static void set_has_gte(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::PROTOBUF_NAMESPACE_ID::Duration&
DurationRules::_Internal::const_(const DurationRules* msg) {
  return *msg->_impl_.const__;
}
const ::PROTOBUF_NAMESPACE_ID::Duration&
DurationRules::_Internal::lt(const DurationRules* msg) {
  return *msg->_impl_.lt_;
}
const ::PROTOBUF_NAMESPACE_ID::Duration&
DurationRules::_Internal::lte(const DurationRules* msg) {
  return *msg->_impl_.lte_;
}
const ::PROTOBUF_NAMESPACE_ID::Duration&
DurationRules::_Internal::gt(const DurationRules* msg) {
  return *msg->_impl_.gt_;
}
const ::PROTOBUF_NAMESPACE_ID::Duration&
DurationRules::_Internal::gte(const DurationRules* msg) {
  return *msg->_impl_.gte_;
}
void DurationRules::clear_const_() {
  if (_impl_.const__ != nullptr) _impl_.const__->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void DurationRules::clear_lt() {
  if (_impl_.lt_ != nullptr) _impl_.lt_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void DurationRules::clear_lte() {
  if (_impl_.lte_ != nullptr) _impl_.lte_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void DurationRules::clear_gt() {
  if (_impl_.gt_ != nullptr) _impl_.gt_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void DurationRules::clear_gte() {
  if (_impl_.gte_ != nullptr) _impl_.gte_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
void DurationRules::clear_in() {
  _impl_.in_.Clear();
}
void DurationRules::clear_not_in() {
  _impl_.not_in_.Clear();
}
DurationRules::DurationRules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:validate.DurationRules)
}
DurationRules::DurationRules(const DurationRules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DurationRules* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.in_){from._impl_.in_}
    , decltype(_impl_.not_in_){from._impl_.not_in_}
    , decltype(_impl_.const__){nullptr}
    , decltype(_impl_.lt_){nullptr}
    , decltype(_impl_.lte_){nullptr}
    , decltype(_impl_.gt_){nullptr}
    , decltype(_impl_.gte_){nullptr}
    , decltype(_impl_.required_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_const_()) {
    _this->_impl_.const__ = new ::PROTOBUF_NAMESPACE_ID::Duration(*from._impl_.const__);
  }
  if (from._internal_has_lt()) {
    _this->_impl_.lt_ = new ::PROTOBUF_NAMESPACE_ID::Duration(*from._impl_.lt_);
  }
  if (from._internal_has_lte()) {
    _this->_impl_.lte_ = new ::PROTOBUF_NAMESPACE_ID::Duration(*from._impl_.lte_);
  }
  if (from._internal_has_gt()) {
    _this->_impl_.gt_ = new ::PROTOBUF_NAMESPACE_ID::Duration(*from._impl_.gt_);
  }
  if (from._internal_has_gte()) {
    _this->_impl_.gte_ = new ::PROTOBUF_NAMESPACE_ID::Duration(*from._impl_.gte_);
  }
  _this->_impl_.required_ = from._impl_.required_;
  // @@protoc_insertion_point(copy_constructor:validate.DurationRules)
}

inline void DurationRules::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.in_){arena}
    , decltype(_impl_.not_in_){arena}
    , decltype(_impl_.const__){nullptr}
    , decltype(_impl_.lt_){nullptr}
    , decltype(_impl_.lte_){nullptr}
    , decltype(_impl_.gt_){nullptr}
    , decltype(_impl_.gte_){nullptr}
    , decltype(_impl_.required_){false}
  };
}

DurationRules::~DurationRules() {
  // @@protoc_insertion_point(destructor:validate.DurationRules)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DurationRules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.in_.~RepeatedPtrField();
  _impl_.not_in_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.const__;
  if (this != internal_default_instance()) delete _impl_.lt_;
  if (this != internal_default_instance()) delete _impl_.lte_;
  if (this != internal_default_instance()) delete _impl_.gt_;
  if (this != internal_default_instance()) delete _impl_.gte_;
}

void DurationRules::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DurationRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.DurationRules)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.const__ != nullptr);
      _impl_.const__->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.lt_ != nullptr);
      _impl_.lt_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.lte_ != nullptr);
      _impl_.lte_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.gt_ != nullptr);
      _impl_.gt_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.gte_ != nullptr);
      _impl_.gte_->Clear();
    }
  }
  _impl_.required_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DurationRules::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool required = 1 [json_name = "required"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_required(&has_bits);
          _impl_.required_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .google.protobuf.Duration const = 2 [json_name = "const"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_const_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .google.protobuf.Duration lt = 3 [json_name = "lt"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_lt(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .google.protobuf.Duration lte = 4 [json_name = "lte"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_lte(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .google.protobuf.Duration gt = 5 [json_name = "gt"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_gt(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .google.protobuf.Duration gte = 6 [json_name = "gte"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_gte(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .google.protobuf.Duration in = 7 [json_name = "in"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_in(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .google.protobuf.Duration not_in = 8 [json_name = "notIn"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_not_in(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DurationRules::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.DurationRules)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool required = 1 [json_name = "required"];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_required(), target);
  }

  // optional .google.protobuf.Duration const = 2 [json_name = "const"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::const_(this),
        _Internal::const_(this).GetCachedSize(), target, stream);
  }

  // optional .google.protobuf.Duration lt = 3 [json_name = "lt"];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::lt(this),
        _Internal::lt(this).GetCachedSize(), target, stream);
  }

  // optional .google.protobuf.Duration lte = 4 [json_name = "lte"];
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::lte(this),
        _Internal::lte(this).GetCachedSize(), target, stream);
  }

  // optional .google.protobuf.Duration gt = 5 [json_name = "gt"];
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::gt(this),
        _Internal::gt(this).GetCachedSize(), target, stream);
  }

  // optional .google.protobuf.Duration gte = 6 [json_name = "gte"];
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::gte(this),
        _Internal::gte(this).GetCachedSize(), target, stream);
  }

  // repeated .google.protobuf.Duration in = 7 [json_name = "in"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_in_size()); i < n; i++) {
    const auto& repfield = this->_internal_in(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .google.protobuf.Duration not_in = 8 [json_name = "notIn"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_not_in_size()); i < n; i++) {
    const auto& repfield = this->_internal_not_in(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.DurationRules)
  return target;
}

size_t DurationRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.DurationRules)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .google.protobuf.Duration in = 7 [json_name = "in"];
  total_size += 1UL * this->_internal_in_size();
  for (const auto& msg : this->_impl_.in_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .google.protobuf.Duration not_in = 8 [json_name = "notIn"];
  total_size += 1UL * this->_internal_not_in_size();
  for (const auto& msg : this->_impl_.not_in_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .google.protobuf.Duration const = 2 [json_name = "const"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.const__);
    }

    // optional .google.protobuf.Duration lt = 3 [json_name = "lt"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.lt_);
    }

    // optional .google.protobuf.Duration lte = 4 [json_name = "lte"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.lte_);
    }

    // optional .google.protobuf.Duration gt = 5 [json_name = "gt"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.gt_);
    }

    // optional .google.protobuf.Duration gte = 6 [json_name = "gte"];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.gte_);
    }

    // optional bool required = 1 [json_name = "required"];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DurationRules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DurationRules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DurationRules::GetClassData() const { return &_class_data_; }


void DurationRules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DurationRules*>(&to_msg);
  auto& from = static_cast<const DurationRules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:validate.DurationRules)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.in_.MergeFrom(from._impl_.in_);
  _this->_impl_.not_in_.MergeFrom(from._impl_.not_in_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_const_()->::PROTOBUF_NAMESPACE_ID::Duration::MergeFrom(
          from._internal_const_());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_lt()->::PROTOBUF_NAMESPACE_ID::Duration::MergeFrom(
          from._internal_lt());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_lte()->::PROTOBUF_NAMESPACE_ID::Duration::MergeFrom(
          from._internal_lte());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_gt()->::PROTOBUF_NAMESPACE_ID::Duration::MergeFrom(
          from._internal_gt());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_gte()->::PROTOBUF_NAMESPACE_ID::Duration::MergeFrom(
          from._internal_gte());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.required_ = from._impl_.required_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DurationRules::CopyFrom(const DurationRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.DurationRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DurationRules::IsInitialized() const {
  return true;
}

void DurationRules::InternalSwap(DurationRules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DurationRules, _impl_.required_)
      + sizeof(DurationRules::_impl_.required_)
      - PROTOBUF_FIELD_OFFSET(DurationRules, _impl_.const__)>(
          reinterpret_cast<char*>(&_impl_.const__),
          reinterpret_cast<char*>(&other->_impl_.const__));
}

::PROTOBUF_NAMESPACE_ID::Metadata DurationRules::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_validate_2fvalidate_2eproto_getter, &descriptor_table_validate_2fvalidate_2eproto_once,
      file_level_metadata_validate_2fvalidate_2eproto[21]);
}

// ===================================================================

class TimestampRules::_Internal {
 public:
  using HasBits = decltype(std::declval<TimestampRules>()._impl_._has_bits_);
  static void set_has_required(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& const_(const TimestampRules* msg);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& lt(const TimestampRules* msg);
  static void set_has_lt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& lte(const TimestampRules* msg);
  static void set_has_lte(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& gt(const TimestampRules* msg);
  static void set_has_gt(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& gte(const TimestampRules* msg);
  static void set_has_gte(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_lt_now(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_gt_now(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Duration& within(const TimestampRules* msg);
  static void set_has_within(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::PROTOBUF_NAMESPACE_ID::Timestamp&
TimestampRules::_Internal::const_(const TimestampRules* msg) {
  return *msg->_impl_.const__;
}
const ::PROTOBUF_NAMESPACE_ID::Timestamp&
TimestampRules::_Internal::lt(const TimestampRules* msg) {
  return *msg->_impl_.lt_;
}
const ::PROTOBUF_NAMESPACE_ID::Timestamp&
TimestampRules::_Internal::lte(const TimestampRules* msg) {
  return *msg->_impl_.lte_;
}
const ::PROTOBUF_NAMESPACE_ID::Timestamp&
TimestampRules::_Internal::gt(const TimestampRules* msg) {
  return *msg->_impl_.gt_;
}
const ::PROTOBUF_NAMESPACE_ID::Timestamp&
TimestampRules::_Internal::gte(const TimestampRules* msg) {
  return *msg->_impl_.gte_;
}
const ::PROTOBUF_NAMESPACE_ID::Duration&
TimestampRules::_Internal::within(const TimestampRules* msg) {
  return *msg->_impl_.within_;
}
void TimestampRules::clear_const_() {
  if (_impl_.const__ != nullptr) _impl_.const__->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void TimestampRules::clear_lt() {
  if (_impl_.lt_ != nullptr) _impl_.lt_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void TimestampRules::clear_lte() {
  if (_impl_.lte_ != nullptr) _impl_.lte_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void TimestampRules::clear_gt() {
  if (_impl_.gt_ != nullptr) _impl_.gt_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void TimestampRules::clear_gte() {
  if (_impl_.gte_ != nullptr) _impl_.gte_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
void TimestampRules::clear_within() {
  if (_impl_.within_ != nullptr) _impl_.within_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
TimestampRules::TimestampRules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:validate.TimestampRules)
}
TimestampRules::TimestampRules(const TimestampRules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TimestampRules* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.const__){nullptr}
    , decltype(_impl_.lt_){nullptr}
    , decltype(_impl_.lte_){nullptr}
    , decltype(_impl_.gt_){nullptr}
    , decltype(_impl_.gte_){nullptr}
    , decltype(_impl_.within_){nullptr}
    , decltype(_impl_.required_){}
    , decltype(_impl_.lt_now_){}
    , decltype(_impl_.gt_now_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_const_()) {
    _this->_impl_.const__ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.const__);
  }
  if (from._internal_has_lt()) {
    _this->_impl_.lt_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.lt_);
  }
  if (from._internal_has_lte()) {
    _this->_impl_.lte_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.lte_);
  }
  if (from._internal_has_gt()) {
    _this->_impl_.gt_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.gt_);
  }
  if (from._internal_has_gte()) {
    _this->_impl_.gte_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.gte_);
  }
  if (from._internal_has_within()) {
    _this->_impl_.within_ = new ::PROTOBUF_NAMESPACE_ID::Duration(*from._impl_.within_);
  }
  ::memcpy(&_impl_.required_, &from._impl_.required_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.gt_now_) -
    reinterpret_cast<char*>(&_impl_.required_)) + sizeof(_impl_.gt_now_));
  // @@protoc_insertion_point(copy_constructor:validate.TimestampRules)
}

inline void TimestampRules::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.const__){nullptr}
    , decltype(_impl_.lt_){nullptr}
    , decltype(_impl_.lte_){nullptr}
    , decltype(_impl_.gt_){nullptr}
    , decltype(_impl_.gte_){nullptr}
    , decltype(_impl_.within_){nullptr}
    , decltype(_impl_.required_){false}
    , decltype(_impl_.lt_now_){false}
    , decltype(_impl_.gt_now_){false}
  };
}

TimestampRules::~TimestampRules() {
  // @@protoc_insertion_point(destructor:validate.TimestampRules)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TimestampRules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.const__;
  if (this != internal_default_instance()) delete _impl_.lt_;
  if (this != internal_default_instance()) delete _impl_.lte_;
  if (this != internal_default_instance()) delete _impl_.gt_;
  if (this != internal_default_instance()) delete _impl_.gte_;
  if (this != internal_default_instance()) delete _impl_.within_;
}

void TimestampRules::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TimestampRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.TimestampRules)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.const__ != nullptr);
      _impl_.const__->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.lt_ != nullptr);
      _impl_.lt_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.lte_ != nullptr);
      _impl_.lte_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.gt_ != nullptr);
      _impl_.gt_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.gte_ != nullptr);
      _impl_.gte_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.within_ != nullptr);
      _impl_.within_->Clear();
    }
  }
  ::memset(&_impl_.required_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.lt_now_) -
      reinterpret_cast<char*>(&_impl_.required_)) + sizeof(_impl_.lt_now_));
  _impl_.gt_now_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TimestampRules::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool required = 1 [json_name = "required"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_required(&has_bits);
          _impl_.required_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .google.protobuf.Timestamp const = 2 [json_name = "const"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_const_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .google.protobuf.Timestamp lt = 3 [json_name = "lt"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_lt(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .google.protobuf.Timestamp lte = 4 [json_name = "lte"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_lte(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .google.protobuf.Timestamp gt = 5 [json_name = "gt"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_gt(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .google.protobuf.Timestamp gte = 6 [json_name = "gte"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_gte(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool lt_now = 7 [json_name = "ltNow"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_lt_now(&has_bits);
          _impl_.lt_now_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool gt_now = 8 [json_name = "gtNow"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_gt_now(&has_bits);
          _impl_.gt_now_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .google.protobuf.Duration within = 9 [json_name = "within"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_within(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TimestampRules::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.TimestampRules)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool required = 1 [json_name = "required"];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_required(), target);
  }

  // optional .google.protobuf.Timestamp const = 2 [json_name = "const"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::const_(this),
        _Internal::const_(this).GetCachedSize(), target, stream);
  }

  // optional .google.protobuf.Timestamp lt = 3 [json_name = "lt"];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::lt(this),
        _Internal::lt(this).GetCachedSize(), target, stream);
  }

  // optional .google.protobuf.Timestamp lte = 4 [json_name = "lte"];
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::lte(this),
        _Internal::lte(this).GetCachedSize(), target, stream);
  }

  // optional .google.protobuf.Timestamp gt = 5 [json_name = "gt"];
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::gt(this),
        _Internal::gt(this).GetCachedSize(), target, stream);
  }

  // optional .google.protobuf.Timestamp gte = 6 [json_name = "gte"];
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::gte(this),
        _Internal::gte(this).GetCachedSize(), target, stream);
  }

  // optional bool lt_now = 7 [json_name = "ltNow"];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_lt_now(), target);
  }

  // optional bool gt_now = 8 [json_name = "gtNow"];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_gt_now(), target);
  }

  // optional .google.protobuf.Duration within = 9 [json_name = "within"];
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::within(this),
        _Internal::within(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.TimestampRules)
  return target;
}

size_t TimestampRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.TimestampRules)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .google.protobuf.Timestamp const = 2 [json_name = "const"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.const__);
    }

    // optional .google.protobuf.Timestamp lt = 3 [json_name = "lt"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.lt_);
    }

    // optional .google.protobuf.Timestamp lte = 4 [json_name = "lte"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.lte_);
    }

    // optional .google.protobuf.Timestamp gt = 5 [json_name = "gt"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.gt_);
    }

    // optional .google.protobuf.Timestamp gte = 6 [json_name = "gte"];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.gte_);
    }

    // optional .google.protobuf.Duration within = 9 [json_name = "within"];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.within_);
    }

    // optional bool required = 1 [json_name = "required"];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool lt_now = 7 [json_name = "ltNow"];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  // optional bool gt_now = 8 [json_name = "gtNow"];
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TimestampRules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TimestampRules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TimestampRules::GetClassData() const { return &_class_data_; }


void TimestampRules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TimestampRules*>(&to_msg);
  auto& from = static_cast<const TimestampRules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:validate.TimestampRules)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_const_()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
          from._internal_const_());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_lt()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
          from._internal_lt());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_lte()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
          from._internal_lte());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_gt()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
          from._internal_gt());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_gte()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
          from._internal_gte());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_within()->::PROTOBUF_NAMESPACE_ID::Duration::MergeFrom(
          from._internal_within());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.required_ = from._impl_.required_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.lt_now_ = from._impl_.lt_now_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_gt_now(from._internal_gt_now());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TimestampRules::CopyFrom(const TimestampRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.TimestampRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TimestampRules::IsInitialized() const {
  return true;
}

void TimestampRules::InternalSwap(TimestampRules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_.gt_now_)
      + sizeof(TimestampRules::_impl_.gt_now_)
      - PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_.const__)>(
          reinterpret_cast<char*>(&_impl_.const__),
          reinterpret_cast<char*>(&other->_impl_.const__));
}

::PROTOBUF_NAMESPACE_ID::Metadata TimestampRules::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_validate_2fvalidate_2eproto_getter, &descriptor_table_validate_2fvalidate_2eproto_once,
      file_level_metadata_validate_2fvalidate_2eproto[22]);
}
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::PROTOBUF_NAMESPACE_ID::MessageOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::PrimitiveTypeTraits< bool >, 8, false>
  disabled(kDisabledFieldNumber, false, nullptr);
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::PROTOBUF_NAMESPACE_ID::MessageOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::PrimitiveTypeTraits< bool >, 8, false>
  ignored(kIgnoredFieldNumber, false, nullptr);
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::PROTOBUF_NAMESPACE_ID::OneofOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::PrimitiveTypeTraits< bool >, 8, false>
  required(kRequiredFieldNumber, false, nullptr);
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::PROTOBUF_NAMESPACE_ID::FieldOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::validate::FieldRules >, 11, false>
  rules(kRulesFieldNumber, ::validate::FieldRules::default_instance(), nullptr);

// @@protoc_insertion_point(namespace_scope)
}  // namespace validate
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::validate::FieldRules*
Arena::CreateMaybeMessage< ::validate::FieldRules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::validate::FieldRules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::FloatRules*
Arena::CreateMaybeMessage< ::validate::FloatRules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::validate::FloatRules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::DoubleRules*
Arena::CreateMaybeMessage< ::validate::DoubleRules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::validate::DoubleRules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::Int32Rules*
Arena::CreateMaybeMessage< ::validate::Int32Rules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::validate::Int32Rules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::Int64Rules*
Arena::CreateMaybeMessage< ::validate::Int64Rules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::validate::Int64Rules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::UInt32Rules*
Arena::CreateMaybeMessage< ::validate::UInt32Rules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::validate::UInt32Rules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::UInt64Rules*
Arena::CreateMaybeMessage< ::validate::UInt64Rules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::validate::UInt64Rules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::SInt32Rules*
Arena::CreateMaybeMessage< ::validate::SInt32Rules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::validate::SInt32Rules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::SInt64Rules*
Arena::CreateMaybeMessage< ::validate::SInt64Rules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::validate::SInt64Rules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::Fixed32Rules*
Arena::CreateMaybeMessage< ::validate::Fixed32Rules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::validate::Fixed32Rules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::Fixed64Rules*
Arena::CreateMaybeMessage< ::validate::Fixed64Rules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::validate::Fixed64Rules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::SFixed32Rules*
Arena::CreateMaybeMessage< ::validate::SFixed32Rules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::validate::SFixed32Rules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::SFixed64Rules*
Arena::CreateMaybeMessage< ::validate::SFixed64Rules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::validate::SFixed64Rules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::BoolRules*
Arena::CreateMaybeMessage< ::validate::BoolRules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::validate::BoolRules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::StringRules*
Arena::CreateMaybeMessage< ::validate::StringRules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::validate::StringRules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::BytesRules*
Arena::CreateMaybeMessage< ::validate::BytesRules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::validate::BytesRules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::EnumRules*
Arena::CreateMaybeMessage< ::validate::EnumRules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::validate::EnumRules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::MessageRules*
Arena::CreateMaybeMessage< ::validate::MessageRules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::validate::MessageRules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::RepeatedRules*
Arena::CreateMaybeMessage< ::validate::RepeatedRules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::validate::RepeatedRules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::MapRules*
Arena::CreateMaybeMessage< ::validate::MapRules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::validate::MapRules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::AnyRules*
Arena::CreateMaybeMessage< ::validate::AnyRules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::validate::AnyRules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::DurationRules*
Arena::CreateMaybeMessage< ::validate::DurationRules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::validate::DurationRules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::TimestampRules*
Arena::CreateMaybeMessage< ::validate::TimestampRules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::validate::TimestampRules >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
